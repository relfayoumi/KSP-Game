/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/colony.ts":
/*!***********************!*\
  !*** ./src/colony.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Colony: () => (/* binding */ Colony),\n/* harmony export */   ColonyMode: () => (/* binding */ ColonyMode),\n/* harmony export */   ModuleType: () => (/* binding */ ModuleType),\n/* harmony export */   ResourceType: () => (/* binding */ ResourceType),\n/* harmony export */   TECHS: () => (/* binding */ TECHS)\n/* harmony export */ });\nvar ResourceType;\n(function (ResourceType) {\n    ResourceType[\"Power\"] = \"Power\";\n    ResourceType[\"Snacks\"] = \"Snacks\";\n    ResourceType[\"BuildingMaterials\"] = \"Building Materials\";\n    ResourceType[\"Science\"] = \"Science\";\n})(ResourceType || (ResourceType = {}));\nvar ModuleType;\n(function (ModuleType) {\n    ModuleType[\"CommandCenter\"] = \"Command Center\";\n    ModuleType[\"Habitation\"] = \"Habitation\";\n    ModuleType[\"Greenhouse\"] = \"Greenhouse\";\n    ModuleType[\"ScienceLab\"] = \"Science Lab\";\n    ModuleType[\"SolarArray\"] = \"Solar Array\";\n    ModuleType[\"MiningRig\"] = \"Mining Rig\";\n    ModuleType[\"CommsRelay\"] = \"Comms Relay\";\n    ModuleType[\"OrbitalAssembly\"] = \"Orbital Assembly\";\n})(ModuleType || (ModuleType = {}));\nvar ColonyMode;\n(function (ColonyMode) {\n    ColonyMode[\"Ground\"] = \"Ground\";\n    ColonyMode[\"Orbital\"] = \"Orbital\";\n})(ColonyMode || (ColonyMode = {}));\nconst M = (entries) => new Map(entries);\nconst MODULE_SPECS = {\n    [ModuleType.CommandCenter]: { cost: M([]), powerGen: 10 },\n    [ModuleType.Habitation]: { cost: M([[ResourceType.BuildingMaterials, 100], [ResourceType.Power, 50]]), powerUse: 2, kerbalCapacity: 5 },\n    [ModuleType.Greenhouse]: { cost: M([[ResourceType.BuildingMaterials, 150], [ResourceType.Power, 100]]), powerUse: 4, snacksGen: 2 },\n    [ModuleType.ScienceLab]: { cost: M([[ResourceType.BuildingMaterials, 200], [ResourceType.Power, 150]]), powerUse: 5, scienceGen: 1 },\n    [ModuleType.SolarArray]: { cost: M([[ResourceType.BuildingMaterials, 120]]), powerGen: 15 },\n    [ModuleType.MiningRig]: { cost: M([[ResourceType.BuildingMaterials, 250], [ResourceType.Power, 100]]), powerUse: 6, materialsGen: 2 },\n    [ModuleType.CommsRelay]: { cost: M([[ResourceType.BuildingMaterials, 80], [ResourceType.Power, 30]]), powerUse: 1 },\n    [ModuleType.OrbitalAssembly]: { cost: M([[ResourceType.BuildingMaterials, 400], [ResourceType.Power, 250]]), powerUse: 8 }\n};\nconst TECHS = {\n    'ISRU': { cost: 500, unlocks: [ModuleType.MiningRig] },\n    'Advanced Power': { cost: 400, unlocks: [ModuleType.SolarArray] },\n    'Comms': { cost: 200, unlocks: [ModuleType.CommsRelay] },\n    'Orbital Assembly': { cost: 800, unlocks: [ModuleType.OrbitalAssembly] }\n};\nclass Colony {\n    constructor() {\n        this.resources = new Map();\n        this.modules = new Map();\n        this.lastUpdateTime = Date.now();\n        // Kerbal stats\n        this.kerbals = 3; // starting crew\n        this.kerbalCapacity = 5; // from habitats\n        // Environment & unlocks\n        this.mode = ColonyMode.Ground;\n        this.unlocked = new Set([\n            ModuleType.Habitation,\n            ModuleType.Greenhouse,\n            ModuleType.SolarArray,\n            ModuleType.ScienceLab,\n            // Ensure Mining Rigs can be built and produce without a tech UI\n            ModuleType.MiningRig\n        ]);\n        // Base resources\n        this.resources.set(ResourceType.Power, 100);\n        this.resources.set(ResourceType.Snacks, 100);\n        this.resources.set(ResourceType.BuildingMaterials, 500);\n        this.resources.set(ResourceType.Science, 0);\n        // Starting modules\n        this.modules.set(ModuleType.CommandCenter, 1);\n        this.modules.set(ModuleType.Habitation, 0);\n        this.modules.set(ModuleType.Greenhouse, 0);\n        this.modules.set(ModuleType.ScienceLab, 0);\n        this.modules.set(ModuleType.SolarArray, 0);\n        this.modules.set(ModuleType.MiningRig, 0);\n        this.modules.set(ModuleType.CommsRelay, 0);\n        this.recomputeKerbalCapacity();\n    }\n    setMode(mode) { this.mode = mode; }\n    isUnlocked(type) { return this.unlocked.has(type) || type === ModuleType.CommandCenter; }\n    unlockTech(id) {\n        const spec = TECHS[id];\n        if (!spec)\n            return false;\n        const sci = this.resources.get(ResourceType.Science) || 0;\n        if (sci < spec.cost)\n            return false;\n        this.resources.set(ResourceType.Science, sci - spec.cost);\n        spec.unlocks.forEach(u => this.unlocked.add(u));\n        return true;\n    }\n    count(type) { return this.modules.get(type) || 0; }\n    recomputeKerbalCapacity() {\n        const base = 5; // command center baseline capacity\n        const fromHab = this.count(ModuleType.Habitation) * (MODULE_SPECS[ModuleType.Habitation].kerbalCapacity || 0);\n        this.kerbalCapacity = base + fromHab;\n        if (this.kerbals > this.kerbalCapacity)\n            this.kerbals = this.kerbalCapacity;\n    }\n    getModuleCost(type) { var _a; return (_a = MODULE_SPECS[type]) === null || _a === void 0 ? void 0 : _a.cost; }\n    canAfford(cost) {\n        let ok = true;\n        cost.forEach((amt, res) => { if ((this.resources.get(res) || 0) < amt)\n            ok = false; });\n        return ok;\n    }\n    // Atomically verify and deduct a cost; returns true on success\n    spend(cost) {\n        if (!this.canAfford(cost))\n            return false;\n        cost.forEach((amt, res) => {\n            const cur = this.resources.get(res) || 0;\n            this.resources.set(res, cur - amt);\n        });\n        return true;\n    }\n    addResource(type, amount) { this.resources.set(type, (this.resources.get(type) || 0) + amount); }\n    removeResource(type, amount) {\n        const cur = this.resources.get(type) || 0;\n        if (cur >= amount) {\n            this.resources.set(type, cur - amount);\n            return true;\n        }\n        return false;\n    }\n    buildModule(type, _cost) {\n        if (!this.isUnlocked(type))\n            return;\n        // Spending is handled by Game.spend before calling this\n        this.modules.set(type, this.count(type) + 1);\n        this.recomputeKerbalCapacity();\n    }\n    solarFactor() {\n        // Orbital gets a buff, ground baseline 1.0 (placeholder for tilt/season/clouds)\n        return this.mode === ColonyMode.Orbital ? 1.4 : 1.0;\n    }\n    miningEnabled() { return this.mode === ColonyMode.Ground; }\n    update() {\n        const now = Date.now();\n        const delta = Math.min(0.25, (now - this.lastUpdateTime) / 1000);\n        this.lastUpdateTime = now;\n        // Aggregate base rates\n        let powerGen = 0, powerUse = 0, snacksGen = 0, matsGen = 0, sciGen = 0;\n        Object.values(ModuleType).forEach((type) => {\n            const spec = MODULE_SPECS[type];\n            if (!spec)\n                return;\n            const n = this.count(type);\n            if (n <= 0)\n                return;\n            // Power generation/usage\n            let pg = (spec.powerGen || 0);\n            if (type === ModuleType.SolarArray)\n                pg *= this.solarFactor();\n            powerGen += pg * n;\n            // Power use for all modules based on total count\n            powerUse += (spec.powerUse || 0) * n;\n            // Resource generation\n            if (type === ModuleType.MiningRig) {\n                let mg = (spec.materialsGen || 0);\n                if (!this.miningEnabled())\n                    mg = 0; // disabled in orbital\n                // Use total number of Mining Rigs built, not just active ones\n                matsGen += mg * n;\n            }\n            else {\n                snacksGen += (spec.snacksGen || 0) * n;\n                matsGen += (spec.materialsGen || 0) * n;\n                sciGen += (spec.scienceGen || 0) * n;\n            }\n        });\n        // Kerbal consumption\n        const snacksUse = this.kerbals * 0.05; // snacks per sec per kerbal\n        // Power factor\n        const totalUse = powerUse;\n        const totalGen = powerGen;\n        let powerFactor = 1;\n        if (totalUse > 0 && totalGen < totalUse)\n            powerFactor = Math.max(0, totalGen / totalUse);\n        // Apply\n        this.addResource(ResourceType.Power, (powerGen - powerUse) * delta);\n        this.addResource(ResourceType.Snacks, (snacksGen - snacksUse) * powerFactor * delta);\n        // Do not throttle mining output by power factor to ensure visible materials gain\n        this.addResource(ResourceType.BuildingMaterials, matsGen * delta);\n        this.addResource(ResourceType.Science, sciGen * powerFactor * delta);\n        // Starvation\n        const snacks = this.resources.get(ResourceType.Snacks) || 0;\n        if (snacks < 0) {\n            this.resources.set(ResourceType.Snacks, 0);\n            this.kerbals = Math.max(0, this.kerbals - 0.01 * delta);\n        }\n        // Simple growth\n        const hasRoom = this.kerbals < this.kerbalCapacity - 0.05;\n        if (hasRoom && snacks > 50)\n            this.kerbals = Math.min(this.kerbalCapacity, this.kerbals + 0.005 * delta);\n    }\n    // Serialization\n    toJSON() {\n        return {\n            resources: Array.from(this.resources.entries()),\n            modules: Array.from(this.modules.entries()),\n            kerbals: this.kerbals,\n            mode: this.mode,\n            unlocked: Array.from(this.unlocked.values())\n        };\n    }\n    static fromJSON(data) {\n        const c = new Colony();\n        if (data === null || data === void 0 ? void 0 : data.resources)\n            c.resources = new Map(data.resources);\n        if (data === null || data === void 0 ? void 0 : data.modules)\n            c.modules = new Map(data.modules);\n        if (typeof (data === null || data === void 0 ? void 0 : data.kerbals) === 'number')\n            c.kerbals = data.kerbals;\n        if ((data === null || data === void 0 ? void 0 : data.mode) && (data.mode === ColonyMode.Ground || data.mode === ColonyMode.Orbital))\n            c.mode = data.mode;\n        if (Array.isArray(data === null || data === void 0 ? void 0 : data.unlocked))\n            c.unlocked = new Set(data.unlocked);\n        c.recomputeKerbalCapacity();\n        return c;\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/colony.ts?\n}");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _colony__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colony */ \"./src/colony.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grid */ \"./src/grid.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n\n\n\n\nclass Game {\n    constructor(canvas) {\n        this.selectedToPlace = null;\n        this.hover = null;\n        // Track module placements to infer active mining rigs\n        this.placements = [];\n        this.isPaused = false;\n        this.keys = {};\n        // Simple key repeat cooldown for grid-snapped movement\n        this.moveCooldown = 0;\n        this.lastTime = performance.now();\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.colony = new _colony__WEBPACK_IMPORTED_MODULE_0__.Colony();\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_1__.UI(this.ctx, this.colony, (mt) => this.beginPlacement(mt), () => this.openInGameMenu(), () => this.cancelPlacement());\n        // Expand map by increasing the number of tiles (not pixel size)\n        this.grid = new _grid__WEBPACK_IMPORTED_MODULE_2__.Grid(60, 36);\n        // Place command center at center\n        const cx = Math.floor(this.grid.width / 2), cy = Math.floor(this.grid.height / 2);\n        this.grid.set(cx, cy, 'C');\n        // Player starts near command center\n        this.px = cx + 1;\n        this.py = cy;\n        // Resize canvas first to set proper dimensions\n        this.resizeCanvas();\n        // Initialize menu system after canvas is properly sized\n        this.menuSystem = new _menu__WEBPACK_IMPORTED_MODULE_3__.MenuSystem(canvas, (state) => this.onMenuStateChange(state));\n        // Ensure we start in main menu state\n        this.menuSystem.setState(_menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu);\n        window.addEventListener('resize', () => {\n            this.resizeCanvas();\n            this.menuSystem.onResize();\n        });\n        this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));\n        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n        window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);\n        window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);\n        this.gameLoop();\n    }\n    resizeCanvas() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        // Scale grid cell size to fit larger maps while keeping UI space\n        const availableW = this.canvas.width - 390; // leave UI margin\n        const availableH = this.canvas.height - 40;\n        this.grid.cellW = Math.floor(Math.max(10, Math.min(22, availableW / this.grid.width)));\n        this.grid.cellH = Math.floor(Math.max(14, Math.min(28, availableH / this.grid.height)));\n        this.grid.originX = 370;\n        this.grid.originY = 20;\n    }\n    beginPlacement(type) {\n        this.selectedToPlace = type;\n        this.ui.setPlacingMode(true);\n    }\n    cancelPlacement() {\n        this.selectedToPlace = null;\n        this.ui.setPlacingMode(false);\n    }\n    onMenuStateChange(state) {\n        switch (state) {\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu:\n                // Only reset game state when returning to main menu (not on initial load)\n                if (this.menuSystem && this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu) {\n                    this.resetGame();\n                }\n                this.isPaused = false;\n                break;\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing:\n                this.isPaused = false;\n                break;\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Paused:\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Settings:\n                this.isPaused = true;\n                break;\n        }\n    }\n    openInGameMenu() {\n        this.menuSystem.setState(_menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Paused);\n    }\n    resetGame() {\n        // Reset colony\n        this.colony = new _colony__WEBPACK_IMPORTED_MODULE_0__.Colony();\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_1__.UI(this.ctx, this.colony, (mt) => this.beginPlacement(mt), () => this.openInGameMenu(), () => this.cancelPlacement());\n        // Reset grid\n        this.grid = new _grid__WEBPACK_IMPORTED_MODULE_2__.Grid(60, 36);\n        // Place command center at center\n        const cx = Math.floor(this.grid.width / 2), cy = Math.floor(this.grid.height / 2);\n        this.grid.set(cx, cy, 'C');\n        // Reset player position\n        this.px = cx + 1;\n        this.py = cy;\n        // Clear placements and selections\n        this.placements = [];\n        this.selectedToPlace = null;\n        this.hover = null;\n    }\n    symbolFor(type) {\n        switch (type) {\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.CommandCenter: return 'C';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Habitation: return 'H';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Greenhouse: return 'G';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ScienceLab: return 'L';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray: return 'S';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig: return 'M';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.CommsRelay: return 'A';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.OrbitalAssembly: return 'O';\n            default: return ' ';\n        }\n    }\n    handleMouseClick(event) {\n        // Menu system handles its own clicks\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        // First pass UI buttons\n        this.ui.buttons.forEach(button => {\n            if (mouseX >= button.rect.x && mouseX <= button.rect.x + button.rect.width &&\n                mouseY >= button.rect.y && mouseY <= button.rect.y + button.rect.height) {\n                if (button.enabled !== false)\n                    button.onClick();\n            }\n        });\n        // Grid placement if a module is selected\n        if (this.selectedToPlace) {\n            const hit = this.grid.hitTest(mouseX, mouseY);\n            if (hit) {\n                const { x, y } = hit;\n                const placing = this.selectedToPlace;\n                const allowed = this.isValidPlacement(x, y, placing);\n                const cost = this.colony.getModuleCost(placing);\n                if (allowed && cost && this.colony.spend(cost)) {\n                    // Deducted successfully; place\n                    this.colony.buildModule(placing, cost);\n                    this.grid.set(x, y, this.symbolFor(placing));\n                    this.placements.push({ x, y, type: placing });\n                    // Keep in placement mode for continuous building\n                    // this.selectedToPlace = null;\n                }\n            }\n        }\n    }\n    handleMouseMove(event) {\n        // Only handle mouse moves when playing\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            this.hover = null;\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        const hit = this.grid.hitTest(mouseX, mouseY);\n        this.hover = hit ? { x: hit.x, y: hit.y } : null;\n    }\n    isValidPlacement(x, y, placing) {\n        // must be empty\n        if (!this.grid.isEmpty(x, y))\n            return false;\n        // mining requires resource tile\n        if (placing === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig && !this.grid.resources[y][x])\n            return false;\n        // adjacency rules: all modules except SolarArray and MiningRig must be adjacent to a connector\n        const requiresAdjacency = placing !== _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray && placing !== _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig;\n        if (!requiresAdjacency)\n            return true;\n        // Check 4-neighborhood for connector module (base or built modules that act as connectors)\n        const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n        for (const [dx, dy] of dirs) {\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 || ny < 0 || nx >= this.grid.width || ny >= this.grid.height)\n                continue;\n            if (this.grid.isConnector(nx, ny))\n                return true;\n        }\n        return false;\n    }\n    stepPlayer(dt) {\n        // Only move player when game is actually playing and not paused\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing || this.isPaused) {\n            return;\n        }\n        this.moveCooldown -= dt;\n        const wantLeft = this.keys['arrowleft'] || this.keys['a'];\n        const wantRight = this.keys['arrowright'] || this.keys['d'];\n        const wantUp = this.keys['arrowup'] || this.keys['w'];\n        const wantDown = this.keys['arrowdown'] || this.keys['s'];\n        if (this.moveCooldown <= 0) {\n            let mx = 0, my = 0;\n            if (wantLeft)\n                mx = -1;\n            else if (wantRight)\n                mx = 1;\n            if (wantUp)\n                my = -1;\n            else if (wantDown)\n                my = 1;\n            if (mx !== 0 || my !== 0) {\n                const nx = Math.max(0, Math.min(this.grid.width - 1, this.px + mx));\n                const ny = Math.max(0, Math.min(this.grid.height - 1, this.py + my));\n                this.px = nx;\n                this.py = ny;\n                // Slow key repeat for easier placement (moves every 120ms while key held)\n                this.moveCooldown = 0.12;\n            }\n        }\n    }\n    drawPlayer() {\n        const { px, py } = this.grid.toPixel(this.px, this.py);\n        this.ctx.save();\n        // Draw a filled circle and an '@' for avatar\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.beginPath();\n        this.ctx.arc(px + this.grid.cellW * 0.5, py + this.grid.cellH * 0.55, Math.min(this.grid.cellW, this.grid.cellH) * 0.35, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.fillStyle = '#000000';\n        this.ctx.font = `${Math.floor(this.grid.cellH * 0.8)}px Consolas, 'Courier New', monospace`;\n        this.ctx.textBaseline = 'middle';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('@', px + this.grid.cellW * 0.5, py + this.grid.cellH * 0.6);\n        this.ctx.restore();\n    }\n    drawHelp() {\n        this.ctx.save();\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '14px Consolas, monospace';\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n        this.ctx.fillText('Move: WASD / Arrow Keys | Place: Click a Place button, then click a grid tile (R for Mining).', 370, this.canvas.height - 20);\n        this.ctx.restore();\n    }\n    gameLoop() {\n        const now = performance.now();\n        const dt = Math.min(0.05, (now - this.lastTime) / 1000);\n        this.lastTime = now;\n        // Only update game state if playing and not paused\n        if (this.menuSystem.getState() === _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing && !this.isPaused) {\n            // Count mining rigs on resource tiles so Colony can compute proper materials gen\n            let activeRigs = 0;\n            for (let y = 0; y < this.grid.height; y++) {\n                for (let x = 0; x < this.grid.width; x++) {\n                    if (this.grid.get(x, y) === 'M' && this.grid.resources[y][x])\n                        activeRigs++;\n                }\n            }\n            this.colony.update();\n            this.stepPlayer(dt);\n        }\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Always set background\n        this.ctx.fillStyle = '#0a0a1a';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw game content only when playing\n        if (this.menuSystem.getState() === _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            // Draw UI + grid + player\n            this.ctx.save();\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'alphabetic';\n            this.ui.draw();\n            this.ctx.restore();\n            this.grid.draw(this.ctx);\n            // Hover ghost for placement\n            if (this.selectedToPlace && this.hover && !this.isPaused) {\n                const { x, y } = this.hover;\n                const ok = this.isValidPlacement(x, y, this.selectedToPlace);\n                const { px, py } = this.grid.toPixel(x, y);\n                this.ctx.save();\n                this.ctx.fillStyle = ok ? 'rgba(0,255,0,0.25)' : 'rgba(255,0,0,0.25)';\n                this.ctx.fillRect(px, py, this.grid.cellW, this.grid.cellH);\n                // show glyph of module to be placed\n                this.ctx.fillStyle = ok ? '#00ff00' : '#ff5555';\n                this.ctx.font = `${Math.max(12, Math.floor(this.grid.cellH * 0.9))}px Consolas, 'Courier New', monospace`;\n                this.ctx.textBaseline = 'top';\n                this.ctx.fillText(this.symbolFor(this.selectedToPlace), px, py);\n                this.ctx.restore();\n            }\n            this.drawPlayer();\n            this.drawHelp();\n        }\n        // Always draw menu system (handles its own visibility)\n        this.menuSystem.draw();\n        // Loop\n        requestAnimationFrame(() => this.gameLoop());\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/game.ts?\n}");

/***/ }),

/***/ "./src/grid.ts":
/*!*********************!*\
  !*** ./src/grid.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Grid: () => (/* binding */ Grid)\n/* harmony export */ });\nclass Grid {\n    constructor(width, height) {\n        // Rendering params (computed by Game)\n        this.cellW = 18;\n        this.cellH = 24;\n        this.originX = 360;\n        this.originY = 20;\n        this.width = width;\n        this.height = height;\n        this.tiles = Array.from({ length: height }, () => Array.from({ length: width }, () => '.'));\n        this.resources = Array.from({ length: height }, () => Array.from({ length: width }, () => false));\n        this.generate();\n    }\n    generate(seed = Date.now()) {\n        // Simple pseudo-random resource distribution\n        let rnd = seed >>> 0;\n        const rand = () => (rnd = (1103515245 * rnd + 12345) >>> 0) / 0xffffffff;\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const r = rand();\n                // 8% chance of a resource deposit\n                const hasRes = r < 0.08;\n                this.resources[y][x] = hasRes;\n                this.tiles[y][x] = hasRes ? 'R' : '.';\n            }\n        }\n    }\n    // Return grid coordinates from a mouse position; undefined if outside\n    hitTest(px, py) {\n        const gx = Math.floor((px - this.originX) / this.cellW);\n        const gy = Math.floor((py - this.originY) / this.cellH);\n        if (gx >= 0 && gy >= 0 && gx < this.width && gy < this.height) {\n            return { x: gx, y: gy };\n        }\n        return undefined;\n    }\n    get(x, y) { return this.tiles[y][x]; }\n    set(x, y, t) { this.tiles[y][x] = t; }\n    isEmpty(x, y) {\n        const t = this.get(x, y);\n        return t === '.' || t === 'R';\n    }\n    // Convert grid coordinates to pixel position\n    toPixel(x, y) {\n        return { px: this.originX + x * this.cellW, py: this.originY + y * this.cellH };\n    }\n    draw(ctx) {\n        ctx.save();\n        const fontPx = Math.max(14, Math.floor(this.cellH * 0.9));\n        ctx.font = `${fontPx}px Consolas, 'Courier New', monospace`;\n        ctx.textBaseline = 'top';\n        // Frame\n        ctx.strokeStyle = '#00ff00';\n        ctx.strokeRect(this.originX - 8, this.originY - 8, this.width * this.cellW + 16, this.height * this.cellH + 16);\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const t = this.tiles[y][x];\n                const px = this.originX + x * this.cellW;\n                const py = this.originY + y * this.cellH;\n                let color = '#00ff00';\n                switch (t) {\n                    case '.':\n                        color = '#2a2a2a';\n                        break; // ground\n                    case 'R':\n                        color = '#1b3b1b';\n                        break; // resource deposit backdrop\n                    case 'C':\n                        color = '#00ff00';\n                        break; // command center\n                    case 'H':\n                        color = '#66ff66';\n                        break; // habitation\n                    case 'G':\n                        color = '#99ff99';\n                        break; // greenhouse\n                    case 'L':\n                        color = '#66ccff';\n                        break; // science lab\n                    case 'S':\n                        color = '#ffff66';\n                        break; // solar\n                    case 'M':\n                        color = '#ffcc66';\n                        break; // mining rig\n                    case 'A':\n                        color = '#ff66cc';\n                        break; // comms relay\n                    case 'O':\n                        color = '#cc66ff';\n                        break; // orbital assembly\n                    default: color = '#00ff00';\n                }\n                // backdrop\n                ctx.fillStyle = color === '#2a2a2a' ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.4)';\n                ctx.fillRect(px, py, this.cellW, this.cellH);\n                // glyph color\n                ctx.fillStyle = color;\n                ctx.fillText(t, px, py);\n            }\n        }\n        ctx.restore();\n    }\n    // Returns true if the tile acts as a connector for branching (base network)\n    // Command Center and built habitat/greenhouse/lab/comms/assembly connect; Solar and Mining do not.\n    isConnector(x, y) {\n        const t = this.get(x, y);\n        return t === 'C' || t === 'H' || t === 'G' || t === 'L' || t === 'A' || t === 'O';\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/grid.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n\nwindow.onload = () => {\n    const canvas = document.getElementById('gameCanvas');\n    // Game constructor now starts with main menu by default\n    new _game__WEBPACK_IMPORTED_MODULE_0__.Game(canvas);\n};\n\n\n//# sourceURL=webpack://ksp-game/./src/index.ts?\n}");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameState: () => (/* binding */ GameState),\n/* harmony export */   MenuSystem: () => (/* binding */ MenuSystem)\n/* harmony export */ });\nvar GameState;\n(function (GameState) {\n    GameState[\"MainMenu\"] = \"MainMenu\";\n    GameState[\"Settings\"] = \"Settings\";\n    GameState[\"Playing\"] = \"Playing\";\n    GameState[\"Paused\"] = \"Paused\";\n})(GameState || (GameState = {}));\nclass MenuSystem {\n    constructor(canvas, onStateChange) {\n        this.currentState = GameState.MainMenu;\n        this.buttons = [];\n        // Settings\n        this.settings = {\n            soundVolume: 100,\n            musicVolume: 80,\n            fullscreen: false\n        };\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.onStateChange = onStateChange;\n        // Handle clicks\n        this.canvas.addEventListener('click', (e) => this.handleClick(e));\n        // Handle ESC key for pause menu\n        window.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape') {\n                if (this.currentState === GameState.Playing) {\n                    this.setState(GameState.Paused);\n                }\n                else if (this.currentState === GameState.Paused) {\n                    this.setState(GameState.Playing);\n                }\n            }\n        });\n        // Setup initial buttons - will be called again in draw() if needed\n        this.setupButtons();\n    }\n    setState(state) {\n        this.currentState = state;\n        this.setupButtons();\n        this.onStateChange(state);\n    }\n    getState() {\n        return this.currentState;\n    }\n    setupButtons() {\n        this.buttons = [];\n        // Ensure canvas has valid dimensions\n        if (this.canvas.width === 0 || this.canvas.height === 0) {\n            return;\n        }\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        const buttonWidth = 200;\n        const buttonHeight = 50;\n        const buttonSpacing = 70;\n        switch (this.currentState) {\n            case GameState.MainMenu:\n                this.buttons = [\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Start Game',\n                        onClick: () => this.setState(GameState.Playing),\n                        color: '#00ff00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Settings',\n                        onClick: () => this.setState(GameState.Settings),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Exit',\n                        onClick: () => this.exitGame(),\n                        color: '#ff4444'\n                    }\n                ];\n                break;\n            case GameState.Settings:\n                this.buttons = [\n                    // Volume controls\n                    {\n                        x: centerX - 120,\n                        y: centerY - 120,\n                        width: 30,\n                        height: 30,\n                        text: '-',\n                        onClick: () => this.adjustVolume('sound', -10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX + 90,\n                        y: centerY - 120,\n                        width: 30,\n                        height: 30,\n                        text: '+',\n                        onClick: () => this.adjustVolume('sound', 10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - 120,\n                        y: centerY - 70,\n                        width: 30,\n                        height: 30,\n                        text: '-',\n                        onClick: () => this.adjustVolume('music', -10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX + 90,\n                        y: centerY - 70,\n                        width: 30,\n                        height: 30,\n                        text: '+',\n                        onClick: () => this.adjustVolume('music', 10),\n                        color: '#ffaa00'\n                    },\n                    // Fullscreen toggle\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - 20,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: this.settings.fullscreen ? 'Windowed Mode' : 'Fullscreen Mode',\n                        onClick: () => this.toggleFullscreen(),\n                        color: '#00aaff'\n                    },\n                    // Back button\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + 60,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Back to Main Menu',\n                        onClick: () => this.setState(GameState.MainMenu),\n                        color: '#888888'\n                    }\n                ];\n                break;\n            case GameState.Paused:\n                this.buttons = [\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Resume Game',\n                        onClick: () => this.setState(GameState.Playing),\n                        color: '#00ff00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Settings',\n                        onClick: () => this.setState(GameState.Settings),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Main Menu',\n                        onClick: () => this.setState(GameState.MainMenu),\n                        color: '#ff4444'\n                    }\n                ];\n                break;\n        }\n        console.log('Setup', this.buttons.length, 'buttons for state:', this.currentState);\n    }\n    handleClick(event) {\n        if (this.currentState === GameState.Playing)\n            return;\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        for (const button of this.buttons) {\n            if (mouseX >= button.x && mouseX <= button.x + button.width &&\n                mouseY >= button.y && mouseY <= button.y + button.height) {\n                if (button.enabled !== false) {\n                    button.onClick();\n                }\n                break;\n            }\n        }\n    }\n    adjustVolume(type, delta) {\n        if (type === 'sound') {\n            this.settings.soundVolume = Math.max(0, Math.min(100, this.settings.soundVolume + delta));\n        }\n        else {\n            this.settings.musicVolume = Math.max(0, Math.min(100, this.settings.musicVolume + delta));\n        }\n        this.setupButtons(); // Refresh to update display\n    }\n    toggleFullscreen() {\n        this.settings.fullscreen = !this.settings.fullscreen;\n        if (this.settings.fullscreen) {\n            if (document.documentElement.requestFullscreen) {\n                document.documentElement.requestFullscreen();\n            }\n        }\n        else {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            }\n        }\n        this.setupButtons(); // Refresh button text\n    }\n    exitGame() {\n        // Close the browser tab/window\n        window.close();\n        // Fallback: redirect to about:blank if window.close() doesn't work\n        setTimeout(() => {\n            window.location.href = 'about:blank';\n        }, 100);\n    }\n    draw() {\n        if (this.currentState === GameState.Playing)\n            return;\n        // Always ensure buttons are set up for non-playing states\n        if (this.canvas.width > 0 && this.canvas.height > 0) {\n            // Force button setup every frame for now to debug\n            this.setupButtons();\n        }\n        // Clear canvas with semi-transparent overlay if paused\n        if (this.currentState === GameState.Paused) {\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        }\n        else {\n            this.ctx.fillStyle = '#0a0a1a';\n        }\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw title\n        this.drawTitle();\n        // Draw settings content if in settings menu\n        if (this.currentState === GameState.Settings) {\n            this.drawSettingsContent();\n        }\n        // Draw buttons\n        this.drawButtons();\n        // Draw version info\n        this.drawVersionInfo();\n    }\n    drawTitle() {\n        const centerX = this.canvas.width / 2;\n        let titleY = this.canvas.height * 0.25;\n        this.ctx.save();\n        // Main title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = 'bold 48px Arial, sans-serif';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText('KSP Colony Simulator', centerX, titleY);\n        // Subtitle based on current state\n        titleY += 60;\n        this.ctx.font = '20px Arial, sans-serif';\n        this.ctx.fillStyle = '#aaaaaa';\n        switch (this.currentState) {\n            case GameState.MainMenu:\n                this.ctx.fillText('Build and manage your Kerbal colony', centerX, titleY);\n                break;\n            case GameState.Settings:\n                this.ctx.fillText('Game Settings', centerX, titleY);\n                break;\n            case GameState.Paused:\n                this.ctx.fillText('Game Paused', centerX, titleY);\n                break;\n        }\n        this.ctx.restore();\n    }\n    drawSettingsContent() {\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        this.ctx.save();\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.font = '16px Arial, sans-serif';\n        this.ctx.textAlign = 'center';\n        // Sound volume\n        this.ctx.fillText(`Sound Volume: ${this.settings.soundVolume}%`, centerX, centerY - 120);\n        // Music volume\n        this.ctx.fillText(`Music Volume: ${this.settings.musicVolume}%`, centerX, centerY - 70);\n        // Controls info\n        this.ctx.fillStyle = '#aaaaaa';\n        this.ctx.font = '14px Arial, sans-serif';\n        this.ctx.fillText('Use +/- buttons to adjust volume', centerX, centerY + 120);\n        this.ctx.fillText('Press ESC to pause/unpause during gameplay', centerX, centerY + 140);\n        this.ctx.restore();\n    }\n    drawButtons() {\n        this.ctx.save();\n        for (const button of this.buttons) {\n            const enabled = button.enabled !== false;\n            const color = button.color || '#00ff00';\n            // Button background\n            this.ctx.fillStyle = enabled ? `${color}20` : 'rgba(100, 100, 100, 0.2)';\n            this.ctx.fillRect(button.x, button.y, button.width, button.height);\n            // Button border\n            this.ctx.strokeStyle = enabled ? color : '#666666';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(button.x, button.y, button.width, button.height);\n            // Button text\n            this.ctx.fillStyle = enabled ? color : '#666666';\n            this.ctx.font = '18px Arial, sans-serif';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);\n        }\n        this.ctx.restore();\n    }\n    drawVersionInfo() {\n        this.ctx.save();\n        this.ctx.fillStyle = '#666666';\n        this.ctx.font = '12px Arial, sans-serif';\n        this.ctx.textAlign = 'right';\n        this.ctx.textBaseline = 'bottom';\n        this.ctx.fillText('v1.0.0', this.canvas.width - 10, this.canvas.height - 10);\n        this.ctx.restore();\n    }\n    // Called when canvas is resized\n    onResize() {\n        this.setupButtons();\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/menu.ts?\n}");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UI: () => (/* binding */ UI)\n/* harmony export */ });\n/* harmony import */ var _colony__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colony */ \"./src/colony.ts\");\n\nvar OverlayState;\n(function (OverlayState) {\n    OverlayState[OverlayState[\"None\"] = 0] = \"None\";\n    OverlayState[OverlayState[\"MainOverlay\"] = 1] = \"MainOverlay\";\n    OverlayState[OverlayState[\"BuildList\"] = 2] = \"BuildList\";\n})(OverlayState || (OverlayState = {}));\nvar BuildCategory;\n(function (BuildCategory) {\n    BuildCategory[BuildCategory[\"Harvesting\"] = 0] = \"Harvesting\";\n    BuildCategory[BuildCategory[\"Habitation\"] = 1] = \"Habitation\";\n    BuildCategory[BuildCategory[\"Power\"] = 2] = \"Power\";\n})(BuildCategory || (BuildCategory = {}));\nclass UI {\n    constructor(ctx, colony, onSelectToPlace, onOpenMenu, onCancelPlacement) {\n        this.buttons = [];\n        this.overlayState = OverlayState.None;\n        this.buildCategory = null;\n        this.placingMode = false;\n        this.showQuickButtons = false;\n        this.ctx = ctx;\n        this.colony = colony;\n        this.onSelectToPlace = onSelectToPlace;\n        this.onOpenMenu = onOpenMenu;\n        this.onCancelPlacement = onCancelPlacement;\n    }\n    draw() {\n        // Reset buttons per frame\n        this.buttons = [];\n        // Establish a known text alignment/baseline so menu/title code from previous frames doesn't leak\n        this.ctx.save();\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n        this.drawResourcePanel();\n        this.drawModulePanel();\n        this.drawMenuButton();\n        this.drawCancelButton();\n        this.drawBuildOverlay();\n        // Restore to avoid leaking our alignment into game / grid rendering\n        this.ctx.restore();\n    }\n    drawResourcePanel() {\n        // resources + kerbals + power net\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.ctx.fillRect(10, 10, 340, 150);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(10, 10, 340, 150);\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '16px Arial';\n        this.ctx.fillText('Colony Status', 20, 30);\n        let y = 52;\n        const print = (label, value) => {\n            this.ctx.fillText(`${label}: ${value}`, 20, y);\n            y += 20;\n        };\n        const power = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Power) || 0);\n        const snacks = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Snacks) || 0);\n        const matsVal = this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.BuildingMaterials) || 0;\n        const sci = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Science) || 0);\n        print('Power', power);\n        print('Snacks', snacks);\n        print('Materials', matsVal.toFixed(1));\n        print('Science', sci);\n        print('Kerbals', this.colony.kerbals.toFixed(1) + ` / ${this.colony.kerbalCapacity}`);\n        // (removed Mat Rate/sec by request)\n    }\n    drawModulePanel() {\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.ctx.fillRect(10, 170, 340, 160);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(10, 170, 340, 160);\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '16px Arial';\n        this.ctx.fillText('Modules', 20, 180);\n        let yOffset = 200;\n        Object.values(_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType).forEach((module) => {\n            const count = this.colony.modules.get(module) || 0;\n            this.ctx.fillText(`${module}: ${count}`, 20, yOffset);\n            yOffset += 20;\n        });\n    }\n    drawMenuButton() {\n        if (!this.onOpenMenu)\n            return;\n        const canvas = this.ctx.canvas;\n        const buttonWidth = 120;\n        const buttonHeight = 35;\n        const margin = 15;\n        const menuBtn = {\n            rect: {\n                x: margin,\n                y: canvas.height - buttonHeight - margin,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'Menu (ESC)',\n            onClick: () => { this.toggleQuickButtons(); },\n            enabled: true\n        };\n        this.buttons.push(menuBtn);\n        // Draw the menu button (isolate alignment changes)\n        this.ctx.save();\n        this.ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';\n        this.ctx.fillRect(menuBtn.rect.x, menuBtn.rect.y, menuBtn.rect.width, menuBtn.rect.height);\n        this.ctx.strokeStyle = '#ffaa00';\n        this.ctx.strokeRect(menuBtn.rect.x, menuBtn.rect.y, menuBtn.rect.width, menuBtn.rect.height);\n        this.ctx.fillStyle = '#ffaa00';\n        this.ctx.font = '14px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(menuBtn.text, menuBtn.rect.x + menuBtn.rect.width / 2, menuBtn.rect.y + menuBtn.rect.height / 2);\n        this.ctx.restore();\n        // Draw quick buttons if they should be shown\n        if (this.showQuickButtons) {\n            this.drawQuickButtons(menuBtn);\n        }\n    }\n    toggleQuickButtons() {\n        if (this.showQuickButtons) {\n            // Second press - open main menu\n            this.showQuickButtons = false;\n            if (this.onOpenMenu) {\n                this.onOpenMenu();\n            }\n        }\n        else {\n            // First press - show quick buttons\n            this.showQuickButtons = true;\n        }\n    }\n    drawQuickButtons(menuBtn) {\n        const buttonWidth = 100;\n        const buttonHeight = 35;\n        const margin = 10;\n        // Build button (above menu button)\n        const buildBtn = {\n            rect: {\n                x: menuBtn.rect.x + (menuBtn.rect.width - buttonWidth) / 2,\n                y: menuBtn.rect.y - buttonHeight - margin,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'Build',\n            onClick: () => {\n                this.showQuickButtons = false;\n                this.showBuildOverlay();\n            },\n            enabled: true\n        };\n        // RD button (to the right of menu button)\n        const rdBtn = {\n            rect: {\n                x: menuBtn.rect.x + menuBtn.rect.width + margin,\n                y: menuBtn.rect.y,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'R&D',\n            onClick: () => {\n                this.showQuickButtons = false;\n                /* No functionality yet */\n            },\n            enabled: false\n        };\n        this.buttons.push(buildBtn, rdBtn);\n        this.drawSimpleButton(buildBtn, '#00ff00');\n        this.drawSimpleButton(rdBtn, '#666666');\n    }\n    drawCancelButton() {\n        // Cancel placement button (top right, only when placing)\n        if (this.placingMode) {\n            const canvas = this.ctx.canvas;\n            const buttonWidth = 100;\n            const buttonHeight = 35;\n            const margin = 15;\n            const cancelBtn = {\n                rect: {\n                    x: canvas.width - buttonWidth - margin,\n                    y: margin,\n                    width: buttonWidth,\n                    height: buttonHeight\n                },\n                text: 'X',\n                onClick: () => { this.cancelPlacement(); },\n                enabled: true\n            };\n            this.buttons.push(cancelBtn);\n            this.drawSimpleButton(cancelBtn, '#ff4444');\n        }\n    }\n    drawSimpleButton(btn, color) {\n        const enabled = btn.enabled !== false;\n        this.ctx.save();\n        this.ctx.fillStyle = enabled ? `${color}30` : 'rgba(100, 100, 100, 0.2)';\n        this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n        this.ctx.strokeStyle = enabled ? color : '#666666';\n        this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n        this.ctx.fillStyle = enabled ? color : '#666666';\n        this.ctx.font = '14px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(btn.text, btn.rect.x + btn.rect.width / 2, btn.rect.y + btn.rect.height / 2);\n        this.ctx.restore();\n    }\n    showBuildOverlay() {\n        this.overlayState = OverlayState.MainOverlay;\n    }\n    cancelPlacement() {\n        this.placingMode = false;\n        this.overlayState = this.buildCategory !== null ? OverlayState.BuildList : OverlayState.MainOverlay;\n        this.showQuickButtons = true; // Show quick buttons again after canceling\n        if (this.onCancelPlacement) {\n            this.onCancelPlacement();\n        }\n    }\n    drawBuildOverlay() {\n        if (this.overlayState === OverlayState.None)\n            return;\n        const canvas = this.ctx.canvas;\n        let overlayWidth = 400;\n        let overlayHeight = 300;\n        // Make overlay larger for building list\n        if (this.overlayState === OverlayState.BuildList) {\n            overlayWidth = 500;\n            overlayHeight = 400;\n        }\n        const overlayX = (canvas.width - overlayWidth) / 2;\n        const overlayY = (canvas.height - overlayHeight) / 2;\n        // Draw overlay background\n        this.ctx.save();\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n        this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n        // Close button (X)\n        const closeBtn = {\n            rect: {\n                x: overlayX + overlayWidth - 40,\n                y: overlayY + 10,\n                width: 30,\n                height: 30\n            },\n            text: 'X',\n            onClick: () => { this.overlayState = OverlayState.None; },\n            enabled: true\n        };\n        this.buttons.push(closeBtn);\n        this.drawSimpleButton(closeBtn, '#ff4444');\n        if (this.overlayState === OverlayState.MainOverlay) {\n            this.drawCategorySelection(overlayX, overlayY, overlayWidth, overlayHeight);\n        }\n        else if (this.overlayState === OverlayState.BuildList && this.buildCategory !== null) {\n            this.drawBuildingList(overlayX, overlayY, overlayWidth, overlayHeight, this.buildCategory);\n        }\n        this.ctx.restore();\n    }\n    drawCategorySelection(overlayX, overlayY, overlayWidth, overlayHeight) {\n        const canvas = this.ctx.canvas;\n        // Title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '20px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'top';\n        this.ctx.fillText('Build Menu', canvas.width / 2, overlayY + 20);\n        // Category buttons\n        const categoryY = overlayY + 80;\n        const categoryWidth = 100;\n        const categoryHeight = 60;\n        const categorySpacing = 120;\n        const startX = overlayX + (overlayWidth - 3 * categoryWidth - 2 * (categorySpacing - categoryWidth)) / 2;\n        const categories = [\n            { name: 'Harvesting', category: BuildCategory.Harvesting, color: '#ffaa00' },\n            { name: 'Habitation\\n& Life', category: BuildCategory.Habitation, color: '#00aaff' },\n            { name: 'Power', category: BuildCategory.Power, color: '#ffff00' }\n        ];\n        categories.forEach((cat, index) => {\n            const btn = {\n                rect: {\n                    x: startX + index * categorySpacing,\n                    y: categoryY,\n                    width: categoryWidth,\n                    height: categoryHeight\n                },\n                text: cat.name,\n                onClick: () => { this.showBuildCategory(cat.category); },\n                enabled: true\n            };\n            this.buttons.push(btn);\n            // Draw category button\n            this.ctx.fillStyle = `${cat.color}30`;\n            this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            this.ctx.strokeStyle = cat.color;\n            this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            this.ctx.fillStyle = cat.color;\n            this.ctx.font = '14px Arial';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            // Handle multi-line text\n            const lines = cat.name.split('\\n');\n            lines.forEach((line, lineIndex) => {\n                this.ctx.fillText(line, btn.rect.x + btn.rect.width / 2, btn.rect.y + btn.rect.height / 2 + (lineIndex - (lines.length - 1) / 2) * 16);\n            });\n        });\n    }\n    drawBuildingList(overlayX, overlayY, overlayWidth, overlayHeight, category) {\n        const canvas = this.ctx.canvas;\n        // Back button\n        const backBtn = {\n            rect: {\n                x: overlayX + 10,\n                y: overlayY + 10,\n                width: 60,\n                height: 30\n            },\n            text: ' Back',\n            onClick: () => { this.overlayState = OverlayState.MainOverlay; },\n            enabled: true\n        };\n        this.buttons.push(backBtn);\n        this.drawSimpleButton(backBtn, '#888888');\n        // Title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '20px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'top';\n        this.ctx.fillText(this.getCategoryName(category), canvas.width / 2, overlayY + 20);\n        // Building list\n        const buildings = this.getBuildingsForCategory(category);\n        const startY = overlayY + 70;\n        const buttonHeight = 80;\n        const buttonSpacing = 10;\n        const buttonWidth = overlayWidth - 40;\n        buildings.forEach((moduleType, index) => {\n            const cost = this.colony.getModuleCost(moduleType);\n            const isUnlocked = this.colony.isUnlocked(moduleType);\n            const canAfford = !!cost && this.colony.canAfford(cost);\n            const enabled = isUnlocked && canAfford;\n            const btn = {\n                rect: {\n                    x: overlayX + 20,\n                    y: startY + index * (buttonHeight + buttonSpacing),\n                    width: buttonWidth,\n                    height: buttonHeight\n                },\n                text: moduleType,\n                onClick: () => { this.selectModuleFromCategory(moduleType); },\n                enabled: enabled\n            };\n            this.buttons.push(btn);\n            // Draw building button\n            const bgColor = enabled ? 'rgba(0, 255, 0, 0.2)' : isUnlocked ? 'rgba(255, 0, 0, 0.2)' : 'rgba(100, 100, 100, 0.2)';\n            const borderColor = enabled ? '#00ff00' : isUnlocked ? '#ff4444' : '#666666';\n            const textColor = enabled ? '#00ff00' : isUnlocked ? '#ff8888' : '#666666';\n            this.ctx.fillStyle = bgColor;\n            this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            this.ctx.strokeStyle = borderColor;\n            this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            // Module name\n            this.ctx.fillStyle = textColor;\n            this.ctx.font = '16px Arial';\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'top';\n            this.ctx.fillText(moduleType, btn.rect.x + 10, btn.rect.y + 10);\n            // Cost information\n            if (cost) {\n                this.ctx.font = '12px Arial';\n                let costY = btn.rect.y + 35;\n                cost.forEach((amount, resourceType) => {\n                    const costText = `${resourceType}: ${amount}`;\n                    this.ctx.fillText(costText, btn.rect.x + 10, costY);\n                    costY += 15;\n                });\n            }\n            // Status text\n            if (!isUnlocked) {\n                this.ctx.fillStyle = '#ff8888';\n                this.ctx.font = '12px Arial';\n                this.ctx.fillText('(Requires Research)', btn.rect.x + 10, btn.rect.y + btn.rect.height - 15);\n            }\n            else if (!canAfford) {\n                this.ctx.fillStyle = '#ff8888';\n                this.ctx.font = '12px Arial';\n                this.ctx.fillText('(Insufficient Resources)', btn.rect.x + 10, btn.rect.y + btn.rect.height - 15);\n            }\n        });\n    }\n    showBuildCategory(category) {\n        this.buildCategory = category;\n        this.overlayState = OverlayState.BuildList;\n    }\n    selectModuleFromCategory(moduleType) {\n        this.overlayState = OverlayState.None;\n        this.placingMode = true;\n        this.showQuickButtons = false; // Hide quick buttons during placement\n        this.onSelectToPlace(moduleType);\n    }\n    getBuildingsForCategory(category) {\n        switch (category) {\n            case BuildCategory.Harvesting:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig];\n            case BuildCategory.Habitation:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Habitation, _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Greenhouse, _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ScienceLab];\n            case BuildCategory.Power:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray];\n            default:\n                return [];\n        }\n    }\n    getCategoryName(category) {\n        switch (category) {\n            case BuildCategory.Harvesting:\n                return 'Harvesting Buildings';\n            case BuildCategory.Habitation:\n                return 'Habitation & Life Support';\n            case BuildCategory.Power:\n                return 'Power Generation';\n            default:\n                return 'Buildings';\n        }\n    }\n    setPlacingMode(placing) {\n        this.placingMode = placing;\n    }\n    isPlacingMode() {\n        return this.placingMode;\n    }\n    hideQuickButtons() {\n        this.showQuickButtons = false;\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/ui.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;