/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/colony.ts":
/*!***********************!*\
  !*** ./src/colony.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Colony: () => (/* binding */ Colony),\n/* harmony export */   ColonyMode: () => (/* binding */ ColonyMode),\n/* harmony export */   ModuleType: () => (/* binding */ ModuleType),\n/* harmony export */   ResourceType: () => (/* binding */ ResourceType),\n/* harmony export */   TECHS: () => (/* binding */ TECHS)\n/* harmony export */ });\nvar ResourceType;\n(function (ResourceType) {\n    ResourceType[\"Power\"] = \"Power\";\n    ResourceType[\"Snacks\"] = \"Snacks\";\n    ResourceType[\"BuildingMaterials\"] = \"Building Materials\";\n    ResourceType[\"Science\"] = \"Science\";\n})(ResourceType || (ResourceType = {}));\nvar ModuleType;\n(function (ModuleType) {\n    ModuleType[\"CommandCenter\"] = \"Command Center\";\n    ModuleType[\"Habitation\"] = \"Habitation\";\n    ModuleType[\"Greenhouse\"] = \"Greenhouse\";\n    ModuleType[\"ScienceLab\"] = \"Science Lab\";\n    ModuleType[\"SolarArray\"] = \"Solar Array\";\n    ModuleType[\"MiningRig\"] = \"Mining Rig\";\n    ModuleType[\"CommsRelay\"] = \"Comms Relay\";\n    ModuleType[\"OrbitalAssembly\"] = \"Orbital Assembly\";\n    // Advanced modules from R&D\n    ModuleType[\"AdvancedHabitat\"] = \"Advanced Habitat\";\n    ModuleType[\"FusionReactor\"] = \"Fusion Reactor\";\n    ModuleType[\"QuantumLab\"] = \"Quantum Lab\";\n    ModuleType[\"PlasmaExtractor\"] = \"Plasma Extractor\";\n    ModuleType[\"ShieldGenerator\"] = \"Shield Generator\";\n    ModuleType[\"TeleportHub\"] = \"Teleport Hub\";\n    ModuleType[\"NanoFactory\"] = \"Nano Factory\";\n    ModuleType[\"ArcReactor\"] = \"Arc Reactor\";\n})(ModuleType || (ModuleType = {}));\nvar ColonyMode;\n(function (ColonyMode) {\n    ColonyMode[\"Ground\"] = \"Ground\";\n    ColonyMode[\"Orbital\"] = \"Orbital\";\n})(ColonyMode || (ColonyMode = {}));\nconst M = (entries) => new Map(entries);\nconst MODULE_SPECS = {\n    // Basic modules\n    [ModuleType.CommandCenter]: { cost: M([]), powerGen: 10 },\n    [ModuleType.Habitation]: { cost: M([[ResourceType.BuildingMaterials, 100], [ResourceType.Power, 50]]), powerUse: 2, kerbalCapacity: 5 },\n    [ModuleType.Greenhouse]: { cost: M([[ResourceType.BuildingMaterials, 150], [ResourceType.Power, 100]]), powerUse: 4, snacksGen: 2 },\n    [ModuleType.ScienceLab]: { cost: M([[ResourceType.BuildingMaterials, 200], [ResourceType.Power, 150]]), powerUse: 5, scienceGen: 1 },\n    [ModuleType.SolarArray]: { cost: M([[ResourceType.BuildingMaterials, 120]]), powerGen: 15 },\n    [ModuleType.MiningRig]: { cost: M([[ResourceType.BuildingMaterials, 250], [ResourceType.Power, 100]]), powerUse: 6, materialsGen: 2 },\n    [ModuleType.CommsRelay]: { cost: M([[ResourceType.BuildingMaterials, 80], [ResourceType.Power, 30]]), powerUse: 1 },\n    [ModuleType.OrbitalAssembly]: { cost: M([[ResourceType.BuildingMaterials, 400], [ResourceType.Power, 250]]), powerUse: 8 },\n    // Advanced modules from R&D\n    [ModuleType.AdvancedHabitat]: { cost: M([[ResourceType.BuildingMaterials, 300], [ResourceType.Power, 150], [ResourceType.Science, 50]]), powerUse: 3, kerbalCapacity: 12 },\n    [ModuleType.FusionReactor]: { cost: M([[ResourceType.BuildingMaterials, 800], [ResourceType.Power, 500], [ResourceType.Science, 200]]), powerGen: 100 },\n    [ModuleType.QuantumLab]: { cost: M([[ResourceType.BuildingMaterials, 600], [ResourceType.Power, 400], [ResourceType.Science, 150]]), powerUse: 12, scienceGen: 5 },\n    [ModuleType.PlasmaExtractor]: { cost: M([[ResourceType.BuildingMaterials, 500], [ResourceType.Power, 300], [ResourceType.Science, 100]]), powerUse: 15, materialsGen: 8 },\n    [ModuleType.ShieldGenerator]: { cost: M([[ResourceType.BuildingMaterials, 1000], [ResourceType.Power, 600], [ResourceType.Science, 300]]), powerUse: 20 },\n    [ModuleType.TeleportHub]: { cost: M([[ResourceType.BuildingMaterials, 1200], [ResourceType.Power, 800], [ResourceType.Science, 400]]), powerUse: 25 },\n    [ModuleType.NanoFactory]: { cost: M([[ResourceType.BuildingMaterials, 1500], [ResourceType.Power, 1000], [ResourceType.Science, 500]]), powerUse: 30, materialsGen: 20 },\n    [ModuleType.ArcReactor]: { cost: M([[ResourceType.BuildingMaterials, 2000], [ResourceType.Power, 1500], [ResourceType.Science, 800]]), powerGen: 500 }\n};\nconst TECHS = {\n    // Tier 1: Basic Technologies (100-500 science)\n    'Basic ISRU': { cost: 100, unlocks: [ModuleType.MiningRig], tier: 1, description: 'Unlock basic resource extraction capabilities' },\n    'Solar Technology': { cost: 150, unlocks: [ModuleType.SolarArray], tier: 1, description: 'Harness solar energy for power generation' },\n    'Communications': { cost: 200, unlocks: [ModuleType.CommsRelay], tier: 1, description: 'Establish communication networks' },\n    'Life Support': { cost: 300, unlocks: [], tier: 1, description: 'Improve habitat efficiency and safety' },\n    // Tier 2: Intermediate Technologies (600-1500 science)\n    'Advanced ISRU': { cost: 800, unlocks: [ModuleType.PlasmaExtractor], prerequisites: ['Basic ISRU'], tier: 2, description: 'Advanced resource extraction using plasma technology' },\n    'Orbital Construction': { cost: 1000, unlocks: [ModuleType.OrbitalAssembly], prerequisites: ['Solar Technology'], tier: 2, description: 'Build structures in orbital environments' },\n    'Enhanced Habitation': { cost: 1200, unlocks: [ModuleType.AdvancedHabitat], prerequisites: ['Life Support'], tier: 2, description: 'Luxurious living spaces with enhanced capacity' },\n    'Advanced Laboratories': { cost: 1500, unlocks: [ModuleType.QuantumLab], prerequisites: ['Communications'], tier: 2, description: 'Quantum-enhanced research capabilities' },\n    // Tier 3: Advanced Technologies (1600-4000 science)\n    'Fusion Technology': { cost: 2200, unlocks: [ModuleType.FusionReactor], prerequisites: ['Advanced ISRU', 'Orbital Construction'], tier: 3, description: 'Clean fusion power generation' },\n    'Quantum Computing': { cost: 2800, unlocks: [], prerequisites: ['Advanced Laboratories'], tier: 3, description: 'Quantum computational advances' },\n    'Plasma Science': { cost: 3200, unlocks: [], prerequisites: ['Advanced ISRU'], tier: 3, description: 'Master plasma state manipulation' },\n    'Energy Shields': { cost: 4000, unlocks: [ModuleType.ShieldGenerator], prerequisites: ['Fusion Technology', 'Quantum Computing'], tier: 3, description: 'Protective energy field technology' },\n    // Tier 4: Cutting-Edge Technologies (4500-7000 science)\n    'Teleportation': { cost: 5000, unlocks: [ModuleType.TeleportHub], prerequisites: ['Quantum Computing', 'Plasma Science'], tier: 4, description: 'Instantaneous matter transportation' },\n    'Nanotechnology': { cost: 5500, unlocks: [ModuleType.NanoFactory], prerequisites: ['Energy Shields'], tier: 4, description: 'Molecular-scale manufacturing' },\n    'Antimatter Research': { cost: 6200, unlocks: [], prerequisites: ['Energy Shields'], tier: 4, description: 'Harness antimatter for ultimate power' },\n    'Spatial Engineering': { cost: 7000, unlocks: [], prerequisites: ['Teleportation'], tier: 4, description: 'Manipulate spacetime itself' },\n    // Tier 5: Ultimate Technologies (7500-10000 science)\n    'Arc Technology': { cost: 8000, unlocks: [ModuleType.ArcReactor], prerequisites: ['Nanotechnology', 'Antimatter Research'], tier: 5, description: 'Ultimate power generation technology' },\n    'Dimensional Physics': { cost: 9000, unlocks: [], prerequisites: ['Spatial Engineering'], tier: 5, description: 'Master interdimensional physics' },\n    'Ultimate Power': { cost: 9500, unlocks: [], prerequisites: ['Arc Technology'], tier: 5, description: 'Achieve unlimited energy potential' },\n    'Transcendence': { cost: 10000, unlocks: [], prerequisites: ['Dimensional Physics', 'Ultimate Power'], tier: 5, description: 'Transcend physical limitations' }\n};\nclass Colony {\n    constructor() {\n        this.resources = new Map();\n        this.modules = new Map();\n        this.lastUpdateTime = Date.now();\n        // Kerbal stats\n        this.kerbals = 3; // starting crew\n        this.kerbalCapacity = 5; // from habitats\n        // Environment & unlocks\n        this.mode = ColonyMode.Ground;\n        this.unlockedTechs = new Set();\n        this.unlocked = new Set([\n            ModuleType.Habitation,\n            ModuleType.Greenhouse,\n            ModuleType.ScienceLab\n            // Other modules require research to unlock\n        ]);\n        // Base resources\n        this.resources.set(ResourceType.Power, 100);\n        this.resources.set(ResourceType.Snacks, 100);\n        this.resources.set(ResourceType.BuildingMaterials, 500);\n        this.resources.set(ResourceType.Science, 0);\n        // Starting modules\n        this.modules.set(ModuleType.CommandCenter, 1);\n        this.modules.set(ModuleType.Habitation, 0);\n        this.modules.set(ModuleType.Greenhouse, 0);\n        this.modules.set(ModuleType.ScienceLab, 0);\n        this.modules.set(ModuleType.SolarArray, 0);\n        this.modules.set(ModuleType.MiningRig, 0);\n        this.modules.set(ModuleType.CommsRelay, 0);\n        this.modules.set(ModuleType.OrbitalAssembly, 0);\n        // Advanced modules\n        this.modules.set(ModuleType.AdvancedHabitat, 0);\n        this.modules.set(ModuleType.FusionReactor, 0);\n        this.modules.set(ModuleType.QuantumLab, 0);\n        this.modules.set(ModuleType.PlasmaExtractor, 0);\n        this.modules.set(ModuleType.ShieldGenerator, 0);\n        this.modules.set(ModuleType.TeleportHub, 0);\n        this.modules.set(ModuleType.NanoFactory, 0);\n        this.modules.set(ModuleType.ArcReactor, 0);\n        this.recomputeKerbalCapacity();\n    }\n    setMode(mode) { this.mode = mode; }\n    isUnlocked(type) { return this.unlocked.has(type) || type === ModuleType.CommandCenter; }\n    unlockTech(id) {\n        const spec = TECHS[id];\n        if (!spec)\n            return false;\n        // Check if already researched\n        if (this.unlockedTechs.has(id))\n            return false;\n        // Check prerequisites\n        if (spec.prerequisites) {\n            for (const prereq of spec.prerequisites) {\n                if (!this.unlockedTechs.has(prereq)) {\n                    return false; // Missing prerequisite\n                }\n            }\n        }\n        // Check science cost\n        const sci = this.resources.get(ResourceType.Science) || 0;\n        if (sci < spec.cost)\n            return false;\n        // Spend science and unlock\n        this.resources.set(ResourceType.Science, sci - spec.cost);\n        this.unlockedTechs.add(id);\n        spec.unlocks.forEach(u => this.unlocked.add(u));\n        return true;\n    }\n    canResearchTech(id) {\n        const spec = TECHS[id];\n        if (!spec || this.unlockedTechs.has(id))\n            return false;\n        // Check prerequisites\n        if (spec.prerequisites) {\n            for (const prereq of spec.prerequisites) {\n                if (!this.unlockedTechs.has(prereq)) {\n                    return false;\n                }\n            }\n        }\n        // Check science cost\n        const sci = this.resources.get(ResourceType.Science) || 0;\n        return sci >= spec.cost;\n    }\n    isResearched(id) {\n        return this.unlockedTechs.has(id);\n    }\n    getAvailableResearch() {\n        return Object.keys(TECHS).filter(id => !this.isResearched(id) &&\n            this.hasPrerequisites(id));\n    }\n    hasPrerequisites(id) {\n        const spec = TECHS[id];\n        if (!spec.prerequisites)\n            return true;\n        return spec.prerequisites.every(prereq => this.unlockedTechs.has(prereq));\n    }\n    count(type) { return this.modules.get(type) || 0; }\n    recomputeKerbalCapacity() {\n        const base = 5; // command center baseline capacity\n        const fromHab = this.count(ModuleType.Habitation) * (MODULE_SPECS[ModuleType.Habitation].kerbalCapacity || 0);\n        this.kerbalCapacity = base + fromHab;\n        if (this.kerbals > this.kerbalCapacity)\n            this.kerbals = this.kerbalCapacity;\n    }\n    getModuleCost(type) { var _a; return (_a = MODULE_SPECS[type]) === null || _a === void 0 ? void 0 : _a.cost; }\n    canAfford(cost) {\n        let ok = true;\n        cost.forEach((amt, res) => { if ((this.resources.get(res) || 0) < amt)\n            ok = false; });\n        return ok;\n    }\n    // Atomically verify and deduct a cost; returns true on success\n    spend(cost) {\n        if (!this.canAfford(cost))\n            return false;\n        cost.forEach((amt, res) => {\n            const cur = this.resources.get(res) || 0;\n            this.resources.set(res, cur - amt);\n        });\n        return true;\n    }\n    addResource(type, amount) { this.resources.set(type, (this.resources.get(type) || 0) + amount); }\n    removeResource(type, amount) {\n        const cur = this.resources.get(type) || 0;\n        if (cur >= amount) {\n            this.resources.set(type, cur - amount);\n            return true;\n        }\n        return false;\n    }\n    buildModule(type, _cost) {\n        if (!this.isUnlocked(type))\n            return;\n        // Spending is handled by Game.spend before calling this\n        this.modules.set(type, this.count(type) + 1);\n        this.recomputeKerbalCapacity();\n    }\n    solarFactor() {\n        // Orbital gets a buff, ground baseline 1.0 (placeholder for tilt/season/clouds)\n        return this.mode === ColonyMode.Orbital ? 1.4 : 1.0;\n    }\n    miningEnabled() { return this.mode === ColonyMode.Ground; }\n    update() {\n        const now = Date.now();\n        const delta = Math.min(0.25, (now - this.lastUpdateTime) / 1000);\n        this.lastUpdateTime = now;\n        // Aggregate base rates\n        let powerGen = 0, powerUse = 0, snacksGen = 0, matsGen = 0, sciGen = 0;\n        Object.values(ModuleType).forEach((type) => {\n            const spec = MODULE_SPECS[type];\n            if (!spec)\n                return;\n            const n = this.count(type);\n            if (n <= 0)\n                return;\n            // Power generation/usage\n            let pg = (spec.powerGen || 0);\n            if (type === ModuleType.SolarArray)\n                pg *= this.solarFactor();\n            powerGen += pg * n;\n            // Power use for all modules based on total count\n            powerUse += (spec.powerUse || 0) * n;\n            // Resource generation\n            if (type === ModuleType.MiningRig) {\n                let mg = (spec.materialsGen || 0);\n                if (!this.miningEnabled())\n                    mg = 0; // disabled in orbital\n                // Use total number of Mining Rigs built, not just active ones\n                matsGen += mg * n;\n            }\n            else {\n                snacksGen += (spec.snacksGen || 0) * n;\n                matsGen += (spec.materialsGen || 0) * n;\n                sciGen += (spec.scienceGen || 0) * n;\n            }\n        });\n        // Kerbal consumption\n        const snacksUse = this.kerbals * 0.05; // snacks per sec per kerbal\n        // Power factor\n        const totalUse = powerUse;\n        const totalGen = powerGen;\n        let powerFactor = 1;\n        if (totalUse > 0 && totalGen < totalUse)\n            powerFactor = Math.max(0, totalGen / totalUse);\n        // Apply\n        this.addResource(ResourceType.Power, (powerGen - powerUse) * delta);\n        this.addResource(ResourceType.Snacks, (snacksGen - snacksUse) * powerFactor * delta);\n        // Do not throttle mining output by power factor to ensure visible materials gain\n        this.addResource(ResourceType.BuildingMaterials, matsGen * delta);\n        this.addResource(ResourceType.Science, sciGen * powerFactor * delta);\n        // Starvation\n        const snacks = this.resources.get(ResourceType.Snacks) || 0;\n        if (snacks < 0) {\n            this.resources.set(ResourceType.Snacks, 0);\n            this.kerbals = Math.max(0, this.kerbals - 0.01 * delta);\n        }\n        // Simple growth\n        const hasRoom = this.kerbals < this.kerbalCapacity - 0.05;\n        if (hasRoom && snacks > 50)\n            this.kerbals = Math.min(this.kerbalCapacity, this.kerbals + 0.005 * delta);\n    }\n    // Serialization\n    toJSON() {\n        return {\n            resources: Array.from(this.resources.entries()),\n            modules: Array.from(this.modules.entries()),\n            kerbals: this.kerbals,\n            mode: this.mode,\n            unlocked: Array.from(this.unlocked.values())\n        };\n    }\n    static fromJSON(data) {\n        const c = new Colony();\n        if (data === null || data === void 0 ? void 0 : data.resources)\n            c.resources = new Map(data.resources);\n        if (data === null || data === void 0 ? void 0 : data.modules)\n            c.modules = new Map(data.modules);\n        if (typeof (data === null || data === void 0 ? void 0 : data.kerbals) === 'number')\n            c.kerbals = data.kerbals;\n        if ((data === null || data === void 0 ? void 0 : data.mode) && (data.mode === ColonyMode.Ground || data.mode === ColonyMode.Orbital))\n            c.mode = data.mode;\n        if (Array.isArray(data === null || data === void 0 ? void 0 : data.unlocked))\n            c.unlocked = new Set(data.unlocked);\n        c.recomputeKerbalCapacity();\n        return c;\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/colony.ts?\n}");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _colony__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colony */ \"./src/colony.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grid */ \"./src/grid.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n\n\n\n\nclass Game {\n    constructor(canvas) {\n        this.selectedToPlace = null;\n        this.hover = null;\n        // Track module placements to infer active mining rigs\n        this.placements = [];\n        this.isPaused = false;\n        this.keys = {};\n        this.moveCooldown = 0;\n        // Oxygen system\n        this.commandCenterX = 0;\n        this.commandCenterY = 0;\n        this.oxygenTimer = 16; // 16 seconds of oxygen\n        this.maxOxygenTime = 16;\n        this.isAwayFromBase = false;\n        // Simple camera follows player directly\n        this.cameraX = 0;\n        this.cameraY = 0;\n        // Animation systems\n        this.constructionSites = [];\n        this.particles = [];\n        this.animationTime = 0;\n        this.lastTime = performance.now();\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.colony = new _colony__WEBPACK_IMPORTED_MODULE_0__.Colony();\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_1__.UI(this.ctx, this.colony, (mt) => this.beginPlacement(mt), () => this.openInGameMenu(), () => this.cancelPlacement());\n        // Open world: Much larger map for exploration\n        this.grid = new _grid__WEBPACK_IMPORTED_MODULE_2__.Grid(200, 150);\n        // Place command center at center\n        const cx = Math.floor(this.grid.width / 2), cy = Math.floor(this.grid.height / 2);\n        this.grid.set(cx, cy, 'C');\n        this.commandCenterX = cx;\n        this.commandCenterY = cy;\n        // Player starts near command center\n        this.px = cx + 1;\n        this.py = cy;\n        // Initialize camera to follow player\n        this.cameraX = this.px;\n        this.cameraY = this.py;\n        // Resize canvas first to set proper dimensions\n        this.resizeCanvas();\n        // Initialize menu system after canvas is properly sized\n        this.menuSystem = new _menu__WEBPACK_IMPORTED_MODULE_3__.MenuSystem(canvas, (state) => this.onMenuStateChange(state), this.colony);\n        // Ensure we start in main menu state\n        this.menuSystem.setState(_menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu);\n        window.addEventListener('resize', () => {\n            this.resizeCanvas();\n            this.menuSystem.onResize();\n        });\n        this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));\n        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n        window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);\n        window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);\n        this.gameLoop();\n    }\n    resizeCanvas() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        this.grid.originX = 370; // Leave space for UI\n        this.grid.originY = 20;\n        // Fixed tile size\n        this.grid.cellW = 24;\n        this.grid.cellH = 24;\n    }\n    updateAnimations(dt) {\n        this.animationTime += dt;\n        // Update construction sites\n        for (let i = this.constructionSites.length - 1; i >= 0; i--) {\n            const site = this.constructionSites[i];\n            const elapsed = this.animationTime - site.startTime;\n            if (elapsed >= site.duration) {\n                // Construction complete - place final symbol\n                this.grid.set(site.x, site.y, this.symbolFor(site.type));\n                this.constructionSites.splice(i, 1);\n            }\n        }\n        // Update particles\n        for (let i = this.particles.length - 1; i >= 0; i--) {\n            const particle = this.particles[i];\n            particle.lifetime -= dt;\n            particle.alpha = particle.lifetime / particle.maxLifetime;\n            if (particle.lifetime <= 0) {\n                this.particles.splice(i, 1);\n            }\n        }\n        // Generate new particles for active modules\n        this.generateModuleParticles();\n    }\n    generateModuleParticles() {\n        // Generate particles every few frames to avoid spam\n        if (this.animationTime % 0.5 < 0.016)\n            return;\n        for (const placement of this.placements) {\n            const { x, y, type } = placement;\n            // Mining rigs on resource tiles\n            if (type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig && this.grid.getResourceWrapped(x, y)) {\n                if (Math.random() < 0.3) {\n                    this.particles.push({\n                        x: x + (Math.random() - 0.5) * 0.8,\n                        y: y + (Math.random() - 0.5) * 0.8,\n                        symbol: Math.random() < 0.33 ? '*' : Math.random() < 0.5 ? '+' : '·',\n                        alpha: 1,\n                        lifetime: 1.0 + Math.random() * 0.5,\n                        maxLifetime: 1.0 + Math.random() * 0.5,\n                        color: '#ffcc00'\n                    });\n                }\n            }\n            // Reactors and power modules\n            if (type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray || type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.FusionReactor || type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ArcReactor) {\n                if (Math.random() < 0.4) {\n                    const symbols = ['⚡', '✦', '✧'];\n                    this.particles.push({\n                        x: x + (Math.random() - 0.5) * 0.6,\n                        y: y + (Math.random() - 0.5) * 0.6,\n                        symbol: symbols[Math.floor(Math.random() * symbols.length)],\n                        alpha: 1,\n                        lifetime: 0.8 + Math.random() * 0.4,\n                        maxLifetime: 0.8 + Math.random() * 0.4,\n                        color: type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.FusionReactor ? '#ff6600' : '#66ccff'\n                    });\n                }\n            }\n        }\n    }\n    beginPlacement(type) {\n        this.selectedToPlace = type;\n        this.ui.setPlacingMode(true);\n        // Debug: Log resource positions when mining rig is selected\n        if (type === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig) {\n            console.log(\"Mining Rig selected - Resource map:\");\n            for (let y = 0; y < Math.min(10, this.grid.height); y++) {\n                let row = \"\";\n                for (let x = 0; x < Math.min(20, this.grid.width); x++) {\n                    row += this.grid.resources[y][x] ? \"R\" : \".\";\n                }\n                console.log(`Row ${y}: ${row}`);\n            }\n        }\n    }\n    cancelPlacement() {\n        this.selectedToPlace = null;\n        this.ui.setPlacingMode(false);\n    }\n    onMenuStateChange(state) {\n        switch (state) {\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu:\n                // Only reset game state when returning to main menu (not on initial load)\n                if (this.menuSystem && this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.MainMenu) {\n                    this.resetGame();\n                }\n                this.isPaused = false;\n                break;\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing:\n                this.isPaused = false;\n                break;\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Paused:\n            case _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Settings:\n                this.isPaused = true;\n                break;\n        }\n    }\n    openInGameMenu() {\n        this.menuSystem.setState(_menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Paused);\n    }\n    resetGame() {\n        // Reset colony\n        this.colony = new _colony__WEBPACK_IMPORTED_MODULE_0__.Colony();\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_1__.UI(this.ctx, this.colony, (mt) => this.beginPlacement(mt), () => this.openInGameMenu(), () => this.cancelPlacement());\n        // Reset grid\n        this.grid = new _grid__WEBPACK_IMPORTED_MODULE_2__.Grid(200, 150);\n        // Place command center at center\n        const cx = Math.floor(this.grid.width / 2), cy = Math.floor(this.grid.height / 2);\n        this.grid.set(cx, cy, 'C');\n        this.commandCenterX = cx;\n        this.commandCenterY = cy;\n        // Reset player position\n        this.px = cx + 1;\n        this.py = cy;\n        this.moveCooldown = 0;\n        // Reset camera\n        this.cameraX = this.px;\n        this.cameraY = this.py;\n        // Reset oxygen system\n        this.oxygenTimer = this.maxOxygenTime;\n        this.isAwayFromBase = false;\n        // Clear placements and selections\n        this.placements = [];\n        this.selectedToPlace = null;\n        this.hover = null;\n    }\n    symbolFor(type) {\n        switch (type) {\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.CommandCenter: return 'C';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Habitation: return 'H';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Greenhouse: return 'G';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ScienceLab: return 'L';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray: return 'S';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig: return 'M';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.CommsRelay: return 'A';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.OrbitalAssembly: return 'O';\n            // Advanced modules\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.AdvancedHabitat: return 'H'; // same tile as habitat\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.FusionReactor: return 'S'; // power source like solar\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.QuantumLab: return 'Q';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.PlasmaExtractor: return 'P';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ShieldGenerator: return 'D';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.TeleportHub: return 'T';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.NanoFactory: return 'N';\n            case _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ArcReactor: return 'S'; // power source like solar\n            default: return ' ';\n        }\n    }\n    handleMouseClick(event) {\n        // Menu system handles its own clicks\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        // First pass UI buttons\n        this.ui.buttons.forEach(button => {\n            if (mouseX >= button.rect.x && mouseX <= button.rect.x + button.rect.width &&\n                mouseY >= button.rect.y && mouseY <= button.rect.y + button.rect.height) {\n                if (button.enabled !== false)\n                    button.onClick();\n            }\n        });\n        // Grid placement if a module is selected\n        if (this.selectedToPlace) {\n            // Convert mouse position to grid coordinates independently of camera\n            const gridMouseX = mouseX - this.grid.originX;\n            const gridMouseY = mouseY - this.grid.originY;\n            // Calculate which tile was clicked based on tile size\n            const tileX = Math.floor(gridMouseX / this.grid.cellW);\n            const tileY = Math.floor(gridMouseY / this.grid.cellH);\n            // Calculate camera-based viewport offset\n            const { startX, startY } = this.getViewportInfo();\n            // Convert screen tile to world tile coordinates\n            const worldX = tileX + Math.floor(startX);\n            const worldY = tileY + Math.floor(startY);\n            // Wrap coordinates to handle world boundaries\n            const wrappedX = ((worldX % this.grid.width) + this.grid.width) % this.grid.width;\n            const wrappedY = ((worldY % this.grid.height) + this.grid.height) % this.grid.height;\n            // Check if click is within valid grid area\n            if (gridMouseX >= 0 && gridMouseY >= 0 && tileX >= 0 && tileY >= 0) {\n                const placing = this.selectedToPlace;\n                const allowed = this.isValidPlacement(wrappedX, wrappedY, placing);\n                const cost = this.colony.getModuleCost(placing);\n                if (allowed && cost && this.colony.spend(cost)) {\n                    // Deducted successfully; start construction\n                    this.colony.buildModule(placing, cost);\n                    this.placements.push({ x: wrappedX, y: wrappedY, type: placing });\n                    // Add construction site for animation\n                    this.constructionSites.push({\n                        x: wrappedX, y: wrappedY, type: placing,\n                        startTime: this.animationTime,\n                        duration: 2.0 + Math.random() * 1.0 // 2-3 seconds\n                    });\n                    // Keep in placement mode for continuous building\n                    // this.selectedToPlace = null;\n                }\n            }\n        }\n    }\n    handleMouseMove(event) {\n        // Only handle mouse moves when playing\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            this.hover = null;\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        // Convert mouse position to grid coordinates independently of camera\n        const gridMouseX = mouseX - this.grid.originX;\n        const gridMouseY = mouseY - this.grid.originY;\n        // Calculate which tile was hovered based on tile size\n        const tileX = Math.floor(gridMouseX / this.grid.cellW);\n        const tileY = Math.floor(gridMouseY / this.grid.cellH);\n        // Calculate camera-based viewport offset\n        const { startX, startY } = this.getViewportInfo();\n        // Convert screen tile to world tile coordinates\n        const worldX = tileX + Math.floor(startX);\n        const worldY = tileY + Math.floor(startY);\n        // Wrap coordinates to handle world boundaries\n        const wrappedX = ((worldX % this.grid.width) + this.grid.width) % this.grid.width;\n        const wrappedY = ((worldY % this.grid.height) + this.grid.height) % this.grid.height;\n        // Set hover if within valid grid area\n        if (gridMouseX >= 0 && gridMouseY >= 0 && tileX >= 0 && tileY >= 0) {\n            this.hover = { x: wrappedX, y: wrappedY };\n        }\n        else {\n            this.hover = null;\n        }\n    }\n    isValidPlacement(x, y, placing) {\n        // must be empty (using wrapped coordinates)\n        const tile = this.grid.getWrapped(x, y);\n        if (!(tile === '.' || tile === '⛰'))\n            return false;\n        // must be within player's placement range (with world wrapping)\n        const maxRange = 3; // tiles\n        const dx1 = Math.abs(x - this.px);\n        const dx2 = this.grid.width - dx1;\n        const dy1 = Math.abs(y - this.py);\n        const dy2 = this.grid.height - dy1;\n        const dx = Math.min(dx1, dx2);\n        const dy = Math.min(dy1, dy2);\n        const distance = Math.max(dx, dy); // use Chebyshev distance (allows diagonal placement)\n        if (distance > maxRange)\n            return false;\n        // must be able to afford the module\n        const cost = this.colony.getModuleCost(placing);\n        if (!cost || !this.colony.canAfford(cost))\n            return false;\n        // mining requires resource tile (with wrapping)\n        if (placing === _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig && !this.grid.getResourceWrapped(x, y))\n            return false;\n        // adjacency rules: all modules except SolarArray and MiningRig must be adjacent to a connector\n        const requiresAdjacency = placing !== _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray && placing !== _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig;\n        if (!requiresAdjacency)\n            return true;\n        // Check 4-neighborhood for connector module (with world wrapping)\n        const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n        for (const [dx, dy] of dirs) {\n            const nx = x + dx, ny = y + dy;\n            const wrappedTile = this.grid.getWrapped(nx, ny);\n            if (wrappedTile === 'C' || wrappedTile === 'H' || wrappedTile === 'G' || wrappedTile === 'L' || wrappedTile === 'A' || wrappedTile === 'O') {\n                return true;\n            }\n        }\n        return false;\n    }\n    stepPlayer(dt) {\n        // Only move player when game is actually playing and not paused\n        if (this.menuSystem.getState() !== _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing || this.isPaused) {\n            return;\n        }\n        // Handle movement cooldown\n        this.moveCooldown -= dt;\n        const wantLeft = this.keys['arrowleft'] || this.keys['a'];\n        const wantRight = this.keys['arrowright'] || this.keys['d'];\n        const wantUp = this.keys['arrowup'] || this.keys['w'];\n        const wantDown = this.keys['arrowdown'] || this.keys['s'];\n        // Discrete tile-based movement\n        if (this.moveCooldown <= 0) {\n            let newX = this.px;\n            let newY = this.py;\n            if (wantLeft)\n                newX--;\n            else if (wantRight)\n                newX++;\n            if (wantUp)\n                newY--;\n            else if (wantDown)\n                newY++;\n            // Only move if position changed\n            if (newX !== this.px || newY !== this.py) {\n                // Handle world wrapping\n                if (newX < 0)\n                    newX = this.grid.width - 1;\n                if (newX >= this.grid.width)\n                    newX = 0;\n                if (newY < 0)\n                    newY = this.grid.height - 1;\n                if (newY >= this.grid.height)\n                    newY = 0;\n                this.px = newX;\n                this.py = newY;\n                // Camera follows player immediately\n                this.cameraX = this.px;\n                this.cameraY = this.py;\n                // Set movement cooldown\n                this.moveCooldown = 0.15; // 150ms between moves\n            }\n        }\n        // Update oxygen system\n        this.updateOxygenSystem(dt);\n        // Update animations\n        this.updateAnimations(dt);\n    }\n    // World wrapping utilities\n    wrapX(x) {\n        return ((x % this.grid.width) + this.grid.width) % this.grid.width;\n    }\n    wrapY(y) {\n        return ((y % this.grid.height) + this.grid.height) % this.grid.height;\n    }\n    wrapCoordinates(x, y) {\n        return { x: this.wrapX(x), y: this.wrapY(y) };\n    }\n    getViewportInfo() {\n        const availableW = this.canvas.width - this.grid.originX - 20;\n        const availableH = this.canvas.height - this.grid.originY - 20;\n        const viewportTilesW = Math.floor(availableW / this.grid.cellW);\n        const viewportTilesH = Math.floor(availableH / this.grid.cellH);\n        const startX = Math.floor(this.cameraX - viewportTilesW / 2);\n        const startY = Math.floor(this.cameraY - viewportTilesH / 2);\n        return { startX, startY, viewportTilesW, viewportTilesH };\n    }\n    updateOxygenSystem(dt) {\n        // Calculate distance from command center using Chebyshev distance with world wrapping\n        const dx1 = Math.abs(this.px - this.commandCenterX);\n        const dx2 = this.grid.width - dx1; // wrapped distance\n        const dy1 = Math.abs(this.py - this.commandCenterY);\n        const dy2 = this.grid.height - dy1; // wrapped distance\n        const dx = Math.min(dx1, dx2);\n        const dy = Math.min(dy1, dy2);\n        const distance = Math.max(dx, dy);\n        const wasAwayFromBase = this.isAwayFromBase;\n        this.isAwayFromBase = distance > 16;\n        if (this.isAwayFromBase) {\n            // Player is away from base, consume oxygen\n            this.oxygenTimer -= dt;\n            if (this.oxygenTimer <= 0) {\n                // Out of oxygen! Move player back towards base or handle death\n                this.oxygenTimer = 0;\n                // For now, just reset oxygen when it runs out (could add death/respawn later)\n                this.oxygenTimer = this.maxOxygenTime;\n            }\n        }\n        else {\n            // Player is close to base, restore oxygen\n            this.oxygenTimer = this.maxOxygenTime;\n        }\n    }\n    drawPlayer() {\n        // Calculate player screen position (grid-aligned)\n        const { startX, startY } = this.getViewportInfo();\n        // Player's relative position in the viewport\n        let relativeX = this.px - startX;\n        let relativeY = this.py - startY;\n        // Handle world wrapping for screen position\n        if (relativeX < 0)\n            relativeX += this.grid.width;\n        if (relativeX >= this.grid.width)\n            relativeX -= this.grid.width;\n        if (relativeY < 0)\n            relativeY += this.grid.height;\n        if (relativeY >= this.grid.height)\n            relativeY -= this.grid.height;\n        const screenX = this.grid.originX + relativeX * this.grid.cellW;\n        const screenY = this.grid.originY + relativeY * this.grid.cellH;\n        this.ctx.save();\n        // Draw a filled circle and an '@' for avatar\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.beginPath();\n        this.ctx.arc(screenX + this.grid.cellW * 0.5, screenY + this.grid.cellH * 0.55, Math.min(this.grid.cellW, this.grid.cellH) * 0.35, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.fillStyle = '#000000';\n        this.ctx.font = `${Math.floor(this.grid.cellH * 0.8)}px Consolas, 'Courier New', monospace`;\n        this.ctx.textBaseline = 'middle';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('@', screenX + this.grid.cellW * 0.5, screenY + this.grid.cellH * 0.6);\n        this.ctx.restore();\n    }\n    drawHelp() {\n        this.ctx.save();\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '14px Consolas, monospace';\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n        this.ctx.fillText('Move: WASD / Arrow Keys | Place: Click a Place button, then click a grid tile (R for Mining).', 370, this.canvas.height - 20);\n        this.ctx.restore();\n    }\n    drawOxygenBar() {\n        // Only show oxygen bar when away from base\n        if (!this.isAwayFromBase)\n            return;\n        this.ctx.save();\n        // Position in bottom left corner, but account for UI buttons\n        const barX = 20;\n        const barY = this.canvas.height - 140; // Move higher to avoid button overlap\n        const barWidth = 200;\n        const barHeight = 20;\n        // Background\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(barX - 10, barY - 30, barWidth + 20, 50);\n        this.ctx.strokeStyle = '#ffffff';\n        this.ctx.strokeRect(barX - 10, barY - 30, barWidth + 20, 50);\n        // Label\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.font = '16px Arial';\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n        this.ctx.fillText('Oxygen', barX, barY - 10);\n        // Oxygen bar background\n        this.ctx.fillStyle = '#333333';\n        this.ctx.fillRect(barX, barY, barWidth, barHeight);\n        this.ctx.strokeStyle = '#ffffff';\n        this.ctx.strokeRect(barX, barY, barWidth, barHeight);\n        // Oxygen bar fill\n        const oxygenPercent = Math.max(0, this.oxygenTimer / this.maxOxygenTime);\n        const fillWidth = barWidth * oxygenPercent;\n        // Color based on oxygen level\n        if (oxygenPercent > 0.5) {\n            this.ctx.fillStyle = '#00ff00'; // Green\n        }\n        else if (oxygenPercent > 0.25) {\n            this.ctx.fillStyle = '#ffff00'; // Yellow\n        }\n        else {\n            this.ctx.fillStyle = '#ff0000'; // Red\n        }\n        this.ctx.fillRect(barX, barY, fillWidth, barHeight);\n        // Time remaining text\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.font = '14px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(`${Math.ceil(this.oxygenTimer)}s`, barX + barWidth / 2, barY + barHeight / 2);\n        this.ctx.restore();\n    }\n    drawConstructionSites() {\n        const { startX, startY, viewportTilesW, viewportTilesH } = this.getViewportInfo();\n        const subTileOffsetX = (this.cameraX - Math.floor(this.cameraX)) * this.grid.cellW;\n        const subTileOffsetY = (this.cameraY - Math.floor(this.cameraY)) * this.grid.cellH;\n        for (const site of this.constructionSites) {\n            // Check if construction site is in viewport\n            const relativeX = site.x - startX;\n            const relativeY = site.y - startY;\n            if (relativeX >= 0 && relativeX <= viewportTilesW && relativeY >= 0 && relativeY <= viewportTilesH) {\n                const screenX = this.grid.originX + relativeX * this.grid.cellW - subTileOffsetX;\n                const screenY = this.grid.originY + relativeY * this.grid.cellH - subTileOffsetY;\n                const elapsed = this.animationTime - site.startTime;\n                const progress = Math.min(elapsed / site.duration, 1.0);\n                this.ctx.save();\n                // Construction phases: ░ → ▒ → ▓ → final\n                let symbol = '░'; // Light shade\n                let alpha = 0.5;\n                if (progress > 0.33) {\n                    symbol = '▒'; // Medium shade\n                    alpha = 0.7;\n                }\n                if (progress > 0.66) {\n                    symbol = '▓'; // Dark shade\n                    alpha = 0.9;\n                }\n                // Pulsing effect\n                const pulse = 0.5 + 0.5 * Math.sin(this.animationTime * 4);\n                alpha *= (0.7 + 0.3 * pulse);\n                this.ctx.globalAlpha = alpha;\n                this.ctx.fillStyle = '#ffaa00';\n                this.ctx.font = `${Math.floor(this.grid.cellH * 0.9)}px Consolas, 'Courier New', monospace`;\n                this.ctx.textAlign = 'left';\n                this.ctx.textBaseline = 'top';\n                this.ctx.fillText(symbol, screenX, screenY);\n                this.ctx.restore();\n            }\n        }\n    }\n    drawParticles() {\n        const { startX, startY, viewportTilesW, viewportTilesH } = this.getViewportInfo();\n        const subTileOffsetX = (this.cameraX - Math.floor(this.cameraX)) * this.grid.cellW;\n        const subTileOffsetY = (this.cameraY - Math.floor(this.cameraY)) * this.grid.cellH;\n        this.ctx.save();\n        for (const particle of this.particles) {\n            // Check if particle is in viewport (with some margin)\n            const relativeX = particle.x - startX;\n            const relativeY = particle.y - startY;\n            if (relativeX >= -1 && relativeX <= viewportTilesW + 1 && relativeY >= -1 && relativeY <= viewportTilesH + 1) {\n                const screenX = this.grid.originX + relativeX * this.grid.cellW - subTileOffsetX;\n                const screenY = this.grid.originY + relativeY * this.grid.cellH - subTileOffsetY;\n                // Blinking effect\n                const blink = 0.5 + 0.5 * Math.sin(this.animationTime * 8 + particle.x + particle.y);\n                const alpha = particle.alpha * (0.6 + 0.4 * blink);\n                this.ctx.globalAlpha = alpha;\n                this.ctx.fillStyle = particle.color;\n                this.ctx.font = `${Math.floor(this.grid.cellH * 0.6)}px Consolas, 'Courier New', monospace`;\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(particle.symbol, screenX + this.grid.cellW * 0.5, screenY + this.grid.cellH * 0.5);\n            }\n        }\n        this.ctx.restore();\n    }\n    gameLoop() {\n        const now = performance.now();\n        const dt = Math.min(0.05, (now - this.lastTime) / 1000);\n        this.lastTime = now;\n        // Only update game state if playing and not paused\n        if (this.menuSystem.getState() === _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing && !this.isPaused) {\n            // Count mining rigs on resource tiles so Colony can compute proper materials gen\n            let activeRigs = 0;\n            for (let y = 0; y < this.grid.height; y++) {\n                for (let x = 0; x < this.grid.width; x++) {\n                    if (this.grid.get(x, y) === 'M' && this.grid.resources[y][x])\n                        activeRigs++;\n                }\n            }\n            this.colony.update();\n            this.stepPlayer(dt);\n        }\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Always set background\n        this.ctx.fillStyle = '#0a0a1a';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw game content only when playing\n        if (this.menuSystem.getState() === _menu__WEBPACK_IMPORTED_MODULE_3__.GameState.Playing) {\n            // Draw grid first (background)\n            this.grid.draw(this.ctx, this.cameraX, this.cameraY);\n            // Hover ghost for placement - always grid-aligned\n            if (this.selectedToPlace && this.hover && !this.isPaused) {\n                const { x, y } = this.hover;\n                const ok = this.isValidPlacement(x, y, this.selectedToPlace);\n                // Calculate viewport info for positioning\n                const { startX, startY, viewportTilesW, viewportTilesH } = this.getViewportInfo();\n                // Calculate hover tile's position relative to viewport start\n                let relativeX = x - Math.floor(startX);\n                let relativeY = y - Math.floor(startY);\n                // Handle world wrapping for display\n                if (relativeX < 0)\n                    relativeX += this.grid.width;\n                if (relativeX >= this.grid.width)\n                    relativeX -= this.grid.width;\n                if (relativeY < 0)\n                    relativeY += this.grid.height;\n                if (relativeY >= this.grid.height)\n                    relativeY -= this.grid.height;\n                // Grid-aligned screen position (no sub-tile camera offset for placement preview)\n                const screenX = this.grid.originX + relativeX * this.grid.cellW;\n                const screenY = this.grid.originY + relativeY * this.grid.cellH;\n                // Only draw if within viewport bounds\n                if (relativeX >= 0 && relativeX < viewportTilesW && relativeY >= 0 && relativeY < viewportTilesH) {\n                    this.ctx.save();\n                    // Pulsing semi-transparent preview with smooth animation\n                    const pulse = 0.7 + 0.3 * Math.sin(this.animationTime * 4);\n                    const alpha = pulse * (ok ? 0.4 : 0.3);\n                    this.ctx.fillStyle = ok ? `rgba(0,255,0,${alpha})` : `rgba(255,0,0,${alpha})`;\n                    this.ctx.fillRect(screenX, screenY, this.grid.cellW, this.grid.cellH);\n                    // Pulsing border\n                    this.ctx.strokeStyle = ok ? `rgba(0,255,0,${pulse})` : `rgba(255,0,0,${pulse})`;\n                    this.ctx.lineWidth = 2;\n                    this.ctx.strokeRect(screenX + 1, screenY + 1, this.grid.cellW - 2, this.grid.cellH - 2);\n                    // Show glyph of module to be placed with smooth color transition\n                    this.ctx.fillStyle = ok ? `rgba(0,255,0,${pulse})` : `rgba(255,85,85,${pulse})`;\n                    this.ctx.font = `${Math.max(12, Math.floor(this.grid.cellH * 0.9))}px Consolas, 'Courier New', monospace`;\n                    this.ctx.textBaseline = 'top';\n                    this.ctx.textAlign = 'left';\n                    this.ctx.fillText(this.symbolFor(this.selectedToPlace), screenX, screenY);\n                    this.ctx.restore();\n                }\n            }\n            this.drawConstructionSites();\n            this.drawParticles();\n            this.drawPlayer();\n            this.drawHelp();\n            this.drawOxygenBar();\n            // Draw UI last so overlays appear on top\n            this.ctx.save();\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'alphabetic';\n            this.ui.draw();\n            this.ctx.restore();\n        }\n        // Always draw menu system (handles its own visibility)\n        this.menuSystem.draw();\n        // Loop\n        requestAnimationFrame(() => this.gameLoop());\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/game.ts?\n}");

/***/ }),

/***/ "./src/grid.ts":
/*!*********************!*\
  !*** ./src/grid.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Grid: () => (/* binding */ Grid)\n/* harmony export */ });\nclass Grid {\n    constructor(width, height) {\n        // Rendering params (computed by Game)\n        this.cellW = 18;\n        this.cellH = 24;\n        this.originX = 360;\n        this.originY = 20;\n        this.width = width;\n        this.height = height;\n        this.tiles = Array.from({ length: height }, () => Array.from({ length: width }, () => '.'));\n        this.resources = Array.from({ length: height }, () => Array.from({ length: width }, () => false));\n        this.generate();\n    }\n    generate(seed = Date.now()) {\n        // Simple pseudo-random resource distribution\n        let rnd = seed >>> 0;\n        const rand = () => (rnd = (1103515245 * rnd + 12345) >>> 0) / 0xffffffff;\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const r = rand();\n                // 2% chance of a resource deposit (reduced from 8% for open world)\n                const hasRes = r < 0.02;\n                this.resources[y][x] = hasRes;\n                this.tiles[y][x] = hasRes ? '⛰' : '.';\n            }\n        }\n    }\n    // Return grid coordinates from a mouse position; undefined if outside\n    hitTest(px, py, cameraX, cameraY, canvasWidth, canvasHeight) {\n        const localX = Math.floor((px - this.originX) / this.cellW);\n        const localY = Math.floor((py - this.originY) / this.cellH);\n        if (cameraX !== undefined && cameraY !== undefined && canvasWidth !== undefined && canvasHeight !== undefined) {\n            // Calculate viewport dimensions using actual canvas size (same as draw method)\n            const availableW = canvasWidth - this.originX - 20;\n            const availableH = canvasHeight - this.originY - 20;\n            const viewportTilesW = Math.floor(availableW / this.cellW);\n            const viewportTilesH = Math.floor(availableH / this.cellH);\n            // Convert local screen coordinates to world coordinates with wrapping\n            const startX = Math.floor(cameraX - viewportTilesW / 2);\n            const startY = Math.floor(cameraY - viewportTilesH / 2);\n            // Check if click is within viewport\n            if (localX >= 0 && localY >= 0 && localX <= viewportTilesW && localY <= viewportTilesH) {\n                const worldX = ((startX + localX) % this.width + this.width) % this.width;\n                const worldY = ((startY + localY) % this.height + this.height) % this.height;\n                return { x: worldX, y: worldY };\n            }\n        }\n        else {\n            // Legacy behavior for non-camera mode\n            if (localX >= 0 && localY >= 0 && localX < this.width && localY < this.height) {\n                return { x: localX, y: localY };\n            }\n        }\n        return undefined;\n    }\n    get(x, y) { return this.tiles[y][x]; }\n    set(x, y, t) { this.tiles[y][x] = t; }\n    // World wrapping get methods\n    getWrapped(x, y) {\n        const wrappedX = ((x % this.width) + this.width) % this.width;\n        const wrappedY = ((y % this.height) + this.height) % this.height;\n        return this.tiles[wrappedY][wrappedX];\n    }\n    getResourceWrapped(x, y) {\n        const wrappedX = ((x % this.width) + this.width) % this.width;\n        const wrappedY = ((y % this.height) + this.height) % this.height;\n        return this.resources[wrappedY][wrappedX];\n    }\n    isEmpty(x, y) {\n        const t = this.get(x, y);\n        return t === '.' || t === '⛰';\n    }\n    // Convert grid coordinates to pixel position\n    toPixel(x, y) {\n        return { px: this.originX + x * this.cellW, py: this.originY + y * this.cellH };\n    }\n    draw(ctx, cameraX, cameraY) {\n        ctx.save();\n        // Scale font size with tile size, but keep it readable\n        const fontPx = Math.max(8, Math.min(32, Math.floor(this.cellH * 0.8)));\n        ctx.font = `${fontPx}px Consolas, 'Courier New', monospace`;\n        ctx.textBaseline = 'top';\n        // Calculate viewport dimensions\n        const availableW = ctx.canvas.width - this.originX - 20;\n        const availableH = ctx.canvas.height - this.originY - 20;\n        const viewportTilesW = Math.floor(availableW / this.cellW);\n        const viewportTilesH = Math.floor(availableH / this.cellH);\n        // Fixed frame around visible area - independent of camera/tiles for stability\n        ctx.strokeStyle = '#00ff00';\n        const frameX = this.originX - 8;\n        const frameY = this.originY - 8;\n        const frameW = viewportTilesW * this.cellW;\n        const frameH = viewportTilesH * this.cellH;\n        ctx.strokeRect(frameX, frameY, frameW + 16, frameH + 16);\n        if (cameraX !== undefined && cameraY !== undefined) {\n            // Set clipping region to prevent tiles from drawing outside frame\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(frameX + 8, frameY + 8, frameW, frameH);\n            ctx.clip();\n            // World wrapping viewport with decimal precision for smooth zoom\n            const startX = Math.floor(cameraX - viewportTilesW / 2);\n            const startY = Math.floor(cameraY - viewportTilesH / 2);\n            // Calculate sub-tile camera offset for smooth positioning\n            const subTileOffsetX = (cameraX - Math.floor(cameraX)) * this.cellW;\n            const subTileOffsetY = (cameraY - Math.floor(cameraY)) * this.cellH;\n            for (let screenY = 0; screenY <= viewportTilesH; screenY++) {\n                for (let screenX = 0; screenX <= viewportTilesW; screenX++) {\n                    // World coordinates with wrapping\n                    const worldX = ((startX + screenX) % this.width + this.width) % this.width;\n                    const worldY = ((startY + screenY) % this.height + this.height) % this.height;\n                    const t = this.tiles[worldY][worldX];\n                    // Screen position with sub-tile offset for smooth camera movement\n                    const px = this.originX + screenX * this.cellW - subTileOffsetX;\n                    const py = this.originY + screenY * this.cellH - subTileOffsetY;\n                    let color = '#00ff00';\n                    switch (t) {\n                        case '.':\n                            color = '#2a2a2a';\n                            break; // ground\n                        case '⛰':\n                            color = '#1b3b1b';\n                            break; // resource deposit backdrop\n                        case 'C':\n                            color = '#00ff00';\n                            break; // command center\n                        case 'H':\n                            color = '#66ff66';\n                            break; // habitation\n                        case 'G':\n                            color = '#99ff99';\n                            break; // greenhouse\n                        case 'L':\n                            color = '#66ccff';\n                            break; // science lab\n                        case 'S':\n                            color = '#ffff66';\n                            break; // solar\n                        case 'M':\n                            color = '#ffcc66';\n                            break; // mining rig\n                        case 'A':\n                            color = '#ff66cc';\n                            break; // comms relay\n                        case 'O':\n                            color = '#cc66ff';\n                            break; // orbital assembly\n                        // Advanced modules with distinctive colors\n                        case 'Q':\n                            color = '#9933ff';\n                            break; // quantum lab - purple\n                        case 'P':\n                            color = '#ff3399';\n                            break; // plasma extractor - magenta\n                        case 'D':\n                            color = '#33ffff';\n                            break; // shield generator - cyan\n                        case 'T':\n                            color = '#ff9933';\n                            break; // teleport hub - orange\n                        case 'N':\n                            color = '#99ff33';\n                            break; // nano factory - lime green\n                        default: color = '#00ff00';\n                    }\n                    // backdrop\n                    ctx.fillStyle = color === '#2a2a2a' ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.4)';\n                    ctx.fillRect(px, py, this.cellW, this.cellH);\n                    // glyph color\n                    ctx.fillStyle = color;\n                    ctx.fillText(t, px, py);\n                }\n            }\n            // Restore clipping\n            ctx.restore();\n        }\n        else {\n            // Legacy non-camera mode\n            for (let y = 0; y < this.height; y++) {\n                for (let x = 0; x < this.width; x++) {\n                    const t = this.tiles[y][x];\n                    const px = this.originX + x * this.cellW;\n                    const py = this.originY + y * this.cellH;\n                    let color = '#00ff00';\n                    switch (t) {\n                        case '.':\n                            color = '#2a2a2a';\n                            break;\n                        case '⛰':\n                            color = '#1b3b1b';\n                            break;\n                        case 'C':\n                            color = '#00ff00';\n                            break;\n                        case 'H':\n                            color = '#66ff66';\n                            break;\n                        case 'G':\n                            color = '#99ff99';\n                            break;\n                        case 'L':\n                            color = '#66ccff';\n                            break;\n                        case 'S':\n                            color = '#ffff66';\n                            break;\n                        case 'M':\n                            color = '#ffcc66';\n                            break;\n                        case 'A':\n                            color = '#ff66cc';\n                            break;\n                        case 'O':\n                            color = '#cc66ff';\n                            break;\n                        default: color = '#00ff00';\n                    }\n                    ctx.fillStyle = color === '#2a2a2a' ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.4)';\n                    ctx.fillRect(px, py, this.cellW, this.cellH);\n                    ctx.fillStyle = color;\n                    ctx.fillText(t, px, py);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    // Returns true if the tile acts as a connector for branching (base network)\n    // Command Center and built habitat/greenhouse/lab/comms/assembly connect; Solar and Mining do not.\n    isConnector(x, y) {\n        const t = this.get(x, y);\n        return t === 'C' || t === 'H' || t === 'G' || t === 'L' || t === 'A' || t === 'O';\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/grid.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n\nwindow.onload = () => {\n    const canvas = document.getElementById('gameCanvas');\n    // Game constructor now starts with main menu by default\n    new _game__WEBPACK_IMPORTED_MODULE_0__.Game(canvas);\n};\n\n\n//# sourceURL=webpack://ksp-game/./src/index.ts?\n}");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameState: () => (/* binding */ GameState),\n/* harmony export */   MenuSystem: () => (/* binding */ MenuSystem)\n/* harmony export */ });\nvar GameState;\n(function (GameState) {\n    GameState[\"MainMenu\"] = \"MainMenu\";\n    GameState[\"Settings\"] = \"Settings\";\n    GameState[\"Playing\"] = \"Playing\";\n    GameState[\"Paused\"] = \"Paused\";\n})(GameState || (GameState = {}));\nclass MenuSystem {\n    constructor(canvas, onStateChange, colony) {\n        this.currentState = GameState.MainMenu;\n        this.buttons = [];\n        this.colony = null;\n        // Settings\n        this.settings = {\n            soundVolume: 100,\n            musicVolume: 80,\n            fullscreen: false\n        };\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.onStateChange = onStateChange;\n        this.colony = colony || null;\n        // Handle clicks\n        this.canvas.addEventListener('click', (e) => this.handleClick(e));\n        // Handle ESC key for pause menu\n        window.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape') {\n                if (this.currentState === GameState.Playing) {\n                    this.setState(GameState.Paused);\n                }\n                else if (this.currentState === GameState.Paused) {\n                    this.setState(GameState.Playing);\n                }\n            }\n        });\n        // Setup initial buttons - will be called again in draw() if needed\n        this.setupButtons();\n    }\n    setState(state) {\n        this.currentState = state;\n        this.setupButtons();\n        this.onStateChange(state);\n    }\n    getState() {\n        return this.currentState;\n    }\n    setColony(colony) {\n        this.colony = colony;\n    }\n    setupButtons() {\n        this.buttons = [];\n        // Ensure canvas has valid dimensions\n        if (this.canvas.width === 0 || this.canvas.height === 0) {\n            return;\n        }\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        const buttonWidth = 200;\n        const buttonHeight = 50;\n        const buttonSpacing = 70;\n        switch (this.currentState) {\n            case GameState.MainMenu:\n                this.buttons = [\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Start Game',\n                        onClick: () => this.setState(GameState.Playing),\n                        color: '#00ff00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Settings',\n                        onClick: () => this.setState(GameState.Settings),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Exit',\n                        onClick: () => this.exitGame(),\n                        color: '#ff4444'\n                    }\n                ];\n                break;\n            case GameState.Settings:\n                this.buttons = [\n                    // Volume controls\n                    {\n                        x: centerX - 120,\n                        y: centerY - 120,\n                        width: 30,\n                        height: 30,\n                        text: '-',\n                        onClick: () => this.adjustVolume('sound', -10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX + 90,\n                        y: centerY - 120,\n                        width: 30,\n                        height: 30,\n                        text: '+',\n                        onClick: () => this.adjustVolume('sound', 10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - 120,\n                        y: centerY - 70,\n                        width: 30,\n                        height: 30,\n                        text: '-',\n                        onClick: () => this.adjustVolume('music', -10),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX + 90,\n                        y: centerY - 70,\n                        width: 30,\n                        height: 30,\n                        text: '+',\n                        onClick: () => this.adjustVolume('music', 10),\n                        color: '#ffaa00'\n                    },\n                    // Fullscreen toggle\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - 20,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: this.settings.fullscreen ? 'Windowed Mode' : 'Fullscreen Mode',\n                        onClick: () => this.toggleFullscreen(),\n                        color: '#00aaff'\n                    },\n                    // Back button\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + 60,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Back to Main Menu',\n                        onClick: () => this.setState(GameState.MainMenu),\n                        color: '#888888'\n                    }\n                ];\n                break;\n            case GameState.Paused:\n                this.buttons = [\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY - buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Resume Game',\n                        onClick: () => this.setState(GameState.Playing),\n                        color: '#00ff00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Settings',\n                        onClick: () => this.setState(GameState.Settings),\n                        color: '#ffaa00'\n                    },\n                    {\n                        x: centerX - buttonWidth / 2,\n                        y: centerY + buttonSpacing,\n                        width: buttonWidth,\n                        height: buttonHeight,\n                        text: 'Main Menu',\n                        onClick: () => this.setState(GameState.MainMenu),\n                        color: '#ff4444'\n                    }\n                ];\n                break;\n        }\n        console.log('Setup', this.buttons.length, 'buttons for state:', this.currentState);\n    }\n    handleClick(event) {\n        if (this.currentState === GameState.Playing)\n            return;\n        const rect = this.canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        for (const button of this.buttons) {\n            if (mouseX >= button.x && mouseX <= button.x + button.width &&\n                mouseY >= button.y && mouseY <= button.y + button.height) {\n                if (button.enabled !== false) {\n                    button.onClick();\n                }\n                break;\n            }\n        }\n    }\n    adjustVolume(type, delta) {\n        if (type === 'sound') {\n            this.settings.soundVolume = Math.max(0, Math.min(100, this.settings.soundVolume + delta));\n        }\n        else {\n            this.settings.musicVolume = Math.max(0, Math.min(100, this.settings.musicVolume + delta));\n        }\n        this.setupButtons(); // Refresh to update display\n    }\n    toggleFullscreen() {\n        this.settings.fullscreen = !this.settings.fullscreen;\n        if (this.settings.fullscreen) {\n            if (document.documentElement.requestFullscreen) {\n                document.documentElement.requestFullscreen();\n            }\n        }\n        else {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            }\n        }\n        this.setupButtons(); // Refresh button text\n    }\n    exitGame() {\n        // Close the browser tab/window\n        window.close();\n        // Fallback: redirect to about:blank if window.close() doesn't work\n        setTimeout(() => {\n            window.location.href = 'about:blank';\n        }, 100);\n    }\n    draw() {\n        if (this.currentState === GameState.Playing)\n            return;\n        // Always ensure buttons are set up for non-playing states\n        if (this.canvas.width > 0 && this.canvas.height > 0) {\n            // Force button setup every frame for now to debug\n            this.setupButtons();\n        }\n        // Clear canvas with semi-transparent overlay if paused\n        if (this.currentState === GameState.Paused) {\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        }\n        else {\n            this.ctx.fillStyle = '#0a0a1a';\n        }\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw title\n        this.drawTitle();\n        // Draw settings content if in settings menu\n        if (this.currentState === GameState.Settings) {\n            this.drawSettingsContent();\n        }\n        // Draw research tree if in research menu\n        // Draw buttons\n        this.drawButtons();\n        // Draw version info\n        this.drawVersionInfo();\n    }\n    drawTitle() {\n        const centerX = this.canvas.width / 2;\n        let titleY = this.canvas.height * 0.25;\n        this.ctx.save();\n        // Main title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = 'bold 48px Arial, sans-serif';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText('KSP Colony Simulator', centerX, titleY);\n        // Subtitle based on current state\n        titleY += 60;\n        this.ctx.font = '20px Arial, sans-serif';\n        this.ctx.fillStyle = '#aaaaaa';\n        switch (this.currentState) {\n            case GameState.MainMenu:\n                this.ctx.fillText('Build and manage your Kerbal colony', centerX, titleY);\n                break;\n            case GameState.Settings:\n                this.ctx.fillText('Game Settings', centerX, titleY);\n                break;\n            case GameState.Paused:\n                this.ctx.fillText('Game Paused', centerX, titleY);\n                break;\n        }\n        this.ctx.restore();\n    }\n    drawSettingsContent() {\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        this.ctx.save();\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.font = '16px Arial, sans-serif';\n        this.ctx.textAlign = 'center';\n        // Sound volume\n        this.ctx.fillText(`Sound Volume: ${this.settings.soundVolume}%`, centerX, centerY - 120);\n        // Music volume\n        this.ctx.fillText(`Music Volume: ${this.settings.musicVolume}%`, centerX, centerY - 70);\n        // Controls info\n        this.ctx.fillStyle = '#aaaaaa';\n        this.ctx.font = '14px Arial, sans-serif';\n        this.ctx.fillText('Use +/- buttons to adjust volume', centerX, centerY + 120);\n        this.ctx.fillText('Press ESC to pause/unpause during gameplay', centerX, centerY + 140);\n        this.ctx.restore();\n    }\n    drawButtons() {\n        this.ctx.save();\n        for (const button of this.buttons) {\n            const enabled = button.enabled !== false;\n            const color = button.color || '#00ff00';\n            // Button background\n            this.ctx.fillStyle = enabled ? `${color}20` : 'rgba(100, 100, 100, 0.2)';\n            this.ctx.fillRect(button.x, button.y, button.width, button.height);\n            // Button border\n            this.ctx.strokeStyle = enabled ? color : '#666666';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(button.x, button.y, button.width, button.height);\n            // Button text\n            this.ctx.fillStyle = enabled ? color : '#666666';\n            this.ctx.font = '18px Arial, sans-serif';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);\n        }\n        this.ctx.restore();\n    }\n    drawVersionInfo() {\n        this.ctx.save();\n        this.ctx.fillStyle = '#666666';\n        this.ctx.font = '12px Arial, sans-serif';\n        this.ctx.textAlign = 'right';\n        this.ctx.textBaseline = 'bottom';\n        this.ctx.fillText('v1.0.0', this.canvas.width - 10, this.canvas.height - 10);\n        this.ctx.restore();\n    }\n    // Called when canvas is resized\n    onResize() {\n        this.setupButtons();\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/menu.ts?\n}");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UI: () => (/* binding */ UI)\n/* harmony export */ });\n/* harmony import */ var _colony__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colony */ \"./src/colony.ts\");\n\nvar OverlayState;\n(function (OverlayState) {\n    OverlayState[OverlayState[\"None\"] = 0] = \"None\";\n    OverlayState[OverlayState[\"MainOverlay\"] = 1] = \"MainOverlay\";\n    OverlayState[OverlayState[\"BuildList\"] = 2] = \"BuildList\";\n    OverlayState[OverlayState[\"Research\"] = 3] = \"Research\";\n})(OverlayState || (OverlayState = {}));\nvar BuildCategory;\n(function (BuildCategory) {\n    BuildCategory[BuildCategory[\"Harvesting\"] = 0] = \"Harvesting\";\n    BuildCategory[BuildCategory[\"Habitation\"] = 1] = \"Habitation\";\n    BuildCategory[BuildCategory[\"Power\"] = 2] = \"Power\";\n})(BuildCategory || (BuildCategory = {}));\nclass UI {\n    constructor(ctx, colony, onSelectToPlace, onOpenMenu, onCancelPlacement) {\n        this.buttons = [];\n        this.overlayState = OverlayState.None;\n        this.buildCategory = null;\n        this.placingMode = false;\n        this.showQuickButtons = false;\n        this.ctx = ctx;\n        this.colony = colony;\n        this.onSelectToPlace = onSelectToPlace;\n        this.onOpenMenu = onOpenMenu;\n        this.onCancelPlacement = onCancelPlacement;\n    }\n    draw() {\n        // Reset buttons per frame\n        this.buttons = [];\n        // Establish a known text alignment/baseline so menu/title code from previous frames doesn't leak\n        this.ctx.save();\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n        this.drawResourcePanel();\n        this.drawModulePanel();\n        this.drawMenuButton();\n        this.drawCancelButton();\n        this.drawBuildOverlay();\n        // Restore to avoid leaking our alignment into game / grid rendering\n        this.ctx.restore();\n    }\n    drawResourcePanel() {\n        // resources + kerbals + power net\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.ctx.fillRect(10, 10, 340, 150);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(10, 10, 340, 150);\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '16px Arial';\n        this.ctx.fillText('Colony Status', 20, 30);\n        let y = 52;\n        const print = (label, value) => {\n            this.ctx.fillText(`${label}: ${value}`, 20, y);\n            y += 20;\n        };\n        const power = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Power) || 0);\n        const snacks = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Snacks) || 0);\n        const matsVal = this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.BuildingMaterials) || 0;\n        const sci = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Science) || 0);\n        print('Power', power);\n        print('Snacks', snacks);\n        print('Materials', matsVal.toFixed(1));\n        print('Science', sci);\n        print('Kerbals', this.colony.kerbals.toFixed(1) + ` / ${this.colony.kerbalCapacity}`);\n        // (removed Mat Rate/sec by request)\n    }\n    drawModulePanel() {\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.ctx.fillRect(10, 170, 340, 160);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(10, 170, 340, 160);\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '16px Arial';\n        this.ctx.fillText('Modules', 20, 180);\n        let yOffset = 200;\n        Object.values(_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType).forEach((module) => {\n            const count = this.colony.modules.get(module) || 0;\n            this.ctx.fillText(`${module}: ${count}`, 20, yOffset);\n            yOffset += 20;\n        });\n    }\n    drawMenuButton() {\n        if (!this.onOpenMenu)\n            return;\n        const canvas = this.ctx.canvas;\n        const buttonWidth = 120;\n        const buttonHeight = 35;\n        const margin = 15;\n        const menuBtn = {\n            rect: {\n                x: margin,\n                y: canvas.height - buttonHeight - margin,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'Menu (ESC)',\n            onClick: () => { this.toggleQuickButtons(); },\n            enabled: true\n        };\n        this.buttons.push(menuBtn);\n        // Draw the menu button (isolate alignment changes)\n        this.ctx.save();\n        this.ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';\n        this.ctx.fillRect(menuBtn.rect.x, menuBtn.rect.y, menuBtn.rect.width, menuBtn.rect.height);\n        this.ctx.strokeStyle = '#ffaa00';\n        this.ctx.strokeRect(menuBtn.rect.x, menuBtn.rect.y, menuBtn.rect.width, menuBtn.rect.height);\n        this.ctx.fillStyle = '#ffaa00';\n        this.ctx.font = '14px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(menuBtn.text, menuBtn.rect.x + menuBtn.rect.width / 2, menuBtn.rect.y + menuBtn.rect.height / 2);\n        this.ctx.restore();\n        // Draw quick buttons if they should be shown\n        if (this.showQuickButtons) {\n            this.drawQuickButtons(menuBtn);\n        }\n    }\n    toggleQuickButtons() {\n        if (this.showQuickButtons) {\n            // Second press - open main menu\n            this.showQuickButtons = false;\n            if (this.onOpenMenu) {\n                this.onOpenMenu();\n            }\n        }\n        else {\n            // First press - show quick buttons\n            this.showQuickButtons = true;\n        }\n    }\n    drawQuickButtons(menuBtn) {\n        const buttonWidth = 100;\n        const buttonHeight = 35;\n        const margin = 10;\n        // Build button (above menu button)\n        const buildBtn = {\n            rect: {\n                x: menuBtn.rect.x + (menuBtn.rect.width - buttonWidth) / 2,\n                y: menuBtn.rect.y - buttonHeight - margin,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'Build',\n            onClick: () => {\n                this.showQuickButtons = false;\n                this.showBuildOverlay();\n            },\n            enabled: true\n        };\n        // RD button (to the right of menu button)\n        const rdBtn = {\n            rect: {\n                x: menuBtn.rect.x + menuBtn.rect.width + margin,\n                y: menuBtn.rect.y,\n                width: buttonWidth,\n                height: buttonHeight\n            },\n            text: 'R&D',\n            onClick: () => {\n                this.showQuickButtons = false;\n                this.showResearchOverlay();\n            },\n            enabled: true\n        };\n        this.buttons.push(buildBtn, rdBtn);\n        this.drawSimpleButton(buildBtn, '#00ff00');\n        this.drawSimpleButton(rdBtn, '#9933ff');\n    }\n    drawCancelButton() {\n        // Cancel placement button (top right, only when placing)\n        if (this.placingMode) {\n            const canvas = this.ctx.canvas;\n            const buttonWidth = 100;\n            const buttonHeight = 35;\n            const margin = 15;\n            const cancelBtn = {\n                rect: {\n                    x: canvas.width - buttonWidth - margin,\n                    y: margin,\n                    width: buttonWidth,\n                    height: buttonHeight\n                },\n                text: 'X',\n                onClick: () => { this.cancelPlacement(); },\n                enabled: true\n            };\n            this.buttons.push(cancelBtn);\n            this.drawSimpleButton(cancelBtn, '#ff4444');\n        }\n    }\n    drawSimpleButton(btn, color) {\n        const enabled = btn.enabled !== false;\n        this.ctx.save();\n        this.ctx.fillStyle = enabled ? `${color}30` : 'rgba(100, 100, 100, 0.2)';\n        this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n        this.ctx.strokeStyle = enabled ? color : '#666666';\n        this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n        this.ctx.fillStyle = enabled ? color : '#666666';\n        this.ctx.font = '14px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(btn.text, btn.rect.x + btn.rect.width / 2, btn.rect.y + btn.rect.height / 2);\n        this.ctx.restore();\n    }\n    showBuildOverlay() {\n        this.overlayState = OverlayState.MainOverlay;\n    }\n    showResearchOverlay() {\n        this.overlayState = OverlayState.Research;\n    }\n    cancelPlacement() {\n        this.placingMode = false;\n        this.overlayState = this.buildCategory !== null ? OverlayState.BuildList : OverlayState.MainOverlay;\n        this.showQuickButtons = true; // Show quick buttons again after canceling\n        if (this.onCancelPlacement) {\n            this.onCancelPlacement();\n        }\n    }\n    drawBuildOverlay() {\n        if (this.overlayState === OverlayState.None)\n            return;\n        const canvas = this.ctx.canvas;\n        let overlayWidth = 400;\n        let overlayHeight = 300;\n        // Make overlay larger for building list and research\n        if (this.overlayState === OverlayState.BuildList) {\n            overlayWidth = 500;\n            overlayHeight = 400;\n        }\n        else if (this.overlayState === OverlayState.Research) {\n            overlayWidth = 700;\n            overlayHeight = 500;\n        }\n        const overlayX = (canvas.width - overlayWidth) / 2;\n        const overlayY = (canvas.height - overlayHeight) / 2;\n        // Draw overlay background\n        this.ctx.save();\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n        this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n        this.ctx.strokeStyle = '#00ff00';\n        this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n        // Close button (X)\n        const closeBtn = {\n            rect: {\n                x: overlayX + overlayWidth - 40,\n                y: overlayY + 10,\n                width: 30,\n                height: 30\n            },\n            text: 'X',\n            onClick: () => {\n                this.overlayState = OverlayState.None;\n                this.showQuickButtons = false; // Hide quick buttons when overlay closes\n            },\n            enabled: true\n        };\n        this.buttons.push(closeBtn);\n        this.drawSimpleButton(closeBtn, '#ff4444');\n        if (this.overlayState === OverlayState.MainOverlay) {\n            this.drawCategorySelection(overlayX, overlayY, overlayWidth, overlayHeight);\n        }\n        else if (this.overlayState === OverlayState.BuildList && this.buildCategory !== null) {\n            this.drawBuildingList(overlayX, overlayY, overlayWidth, overlayHeight, this.buildCategory);\n        }\n        else if (this.overlayState === OverlayState.Research) {\n            this.drawResearchTree(overlayX, overlayY, overlayWidth, overlayHeight);\n        }\n        this.ctx.restore();\n    }\n    drawCategorySelection(overlayX, overlayY, overlayWidth, overlayHeight) {\n        const canvas = this.ctx.canvas;\n        // Title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '20px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'top';\n        this.ctx.fillText('Build Menu', canvas.width / 2, overlayY + 20);\n        // Category buttons\n        const categoryY = overlayY + 80;\n        const categoryWidth = 100;\n        const categoryHeight = 60;\n        const categorySpacing = 120;\n        const startX = overlayX + (overlayWidth - 3 * categoryWidth - 2 * (categorySpacing - categoryWidth)) / 2;\n        const categories = [\n            { name: 'Harvesting', category: BuildCategory.Harvesting, color: '#ffaa00' },\n            { name: 'Habitation\\n& Life', category: BuildCategory.Habitation, color: '#00aaff' },\n            { name: 'Power', category: BuildCategory.Power, color: '#ffff00' }\n        ];\n        categories.forEach((cat, index) => {\n            const btn = {\n                rect: {\n                    x: startX + index * categorySpacing,\n                    y: categoryY,\n                    width: categoryWidth,\n                    height: categoryHeight\n                },\n                text: cat.name,\n                onClick: () => { this.showBuildCategory(cat.category); },\n                enabled: true\n            };\n            this.buttons.push(btn);\n            // Draw category button\n            this.ctx.fillStyle = `${cat.color}30`;\n            this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            this.ctx.strokeStyle = cat.color;\n            this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            // Draw category text\n            this.ctx.fillStyle = cat.color;\n            this.ctx.font = '14px Arial';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            // Handle multi-line text\n            const lines = cat.name.split('\\n');\n            lines.forEach((line, lineIndex) => {\n                this.ctx.fillText(line, btn.rect.x + btn.rect.width / 2, btn.rect.y + btn.rect.height / 2 + (lineIndex - (lines.length - 1) / 2) * 16);\n            });\n        });\n    }\n    drawBuildingList(overlayX, overlayY, overlayWidth, overlayHeight, category) {\n        const canvas = this.ctx.canvas;\n        // Back button\n        const backBtn = {\n            rect: {\n                x: overlayX + 10,\n                y: overlayY + 10,\n                width: 60,\n                height: 30\n            },\n            text: '← Back',\n            onClick: () => { this.overlayState = OverlayState.MainOverlay; },\n            enabled: true\n        };\n        this.buttons.push(backBtn);\n        this.drawSimpleButton(backBtn, '#888888');\n        // Title\n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.font = '20px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'top';\n        this.ctx.fillText(this.getCategoryName(category), canvas.width / 2, overlayY + 20);\n        // Building list\n        const buildings = this.getBuildingsForCategory(category);\n        const startY = overlayY + 70;\n        const buttonHeight = 80;\n        const buttonSpacing = 10;\n        const buttonWidth = overlayWidth - 40;\n        buildings.forEach((moduleType, index) => {\n            const cost = this.colony.getModuleCost(moduleType);\n            const isUnlocked = this.colony.isUnlocked(moduleType);\n            const canAfford = !!cost && this.colony.canAfford(cost);\n            const enabled = isUnlocked && canAfford;\n            const btn = {\n                rect: {\n                    x: overlayX + 20,\n                    y: startY + index * (buttonHeight + buttonSpacing),\n                    width: buttonWidth,\n                    height: buttonHeight\n                },\n                text: moduleType,\n                onClick: () => { this.selectModuleFromCategory(moduleType); },\n                enabled: enabled\n            };\n            this.buttons.push(btn);\n            // Draw building button\n            const bgColor = enabled ? 'rgba(0, 255, 0, 0.2)' : isUnlocked ? 'rgba(255, 0, 0, 0.2)' : 'rgba(100, 100, 100, 0.2)';\n            const borderColor = enabled ? '#00ff00' : isUnlocked ? '#ff4444' : '#666666';\n            const textColor = enabled ? '#00ff00' : isUnlocked ? '#ff8888' : '#666666';\n            this.ctx.fillStyle = bgColor;\n            this.ctx.fillRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            this.ctx.strokeStyle = borderColor;\n            this.ctx.strokeRect(btn.rect.x, btn.rect.y, btn.rect.width, btn.rect.height);\n            // Module name\n            this.ctx.fillStyle = textColor;\n            this.ctx.font = '16px Arial';\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'top';\n            this.ctx.fillText(moduleType, btn.rect.x + 10, btn.rect.y + 10);\n            // Cost information\n            if (cost) {\n                this.ctx.font = '12px Arial';\n                let costY = btn.rect.y + 35;\n                cost.forEach((amount, resourceType) => {\n                    const costText = `${resourceType}: ${amount}`;\n                    this.ctx.fillText(costText, btn.rect.x + 10, costY);\n                    costY += 15;\n                });\n            }\n            // Status text\n            if (!isUnlocked) {\n                this.ctx.fillStyle = '#ff8888';\n                this.ctx.font = '12px Arial';\n                this.ctx.fillText('(Requires Research)', btn.rect.x + 10, btn.rect.y + btn.rect.height - 15);\n            }\n            else if (!canAfford) {\n                this.ctx.fillStyle = '#ff8888';\n                this.ctx.font = '12px Arial';\n                this.ctx.fillText('(Insufficient Resources)', btn.rect.x + 10, btn.rect.y + btn.rect.height - 15);\n            }\n        });\n    }\n    showBuildCategory(category) {\n        this.buildCategory = category;\n        this.overlayState = OverlayState.BuildList;\n    }\n    selectModuleFromCategory(moduleType) {\n        this.overlayState = OverlayState.None;\n        this.placingMode = true;\n        this.showQuickButtons = false; // Hide quick buttons during placement\n        this.onSelectToPlace(moduleType);\n    }\n    getBuildingsForCategory(category) {\n        switch (category) {\n            case BuildCategory.Harvesting:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.MiningRig];\n            case BuildCategory.Habitation:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Habitation, _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.Greenhouse, _colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.ScienceLab];\n            case BuildCategory.Power:\n                return [_colony__WEBPACK_IMPORTED_MODULE_0__.ModuleType.SolarArray];\n            default:\n                return [];\n        }\n    }\n    getCategoryName(category) {\n        switch (category) {\n            case BuildCategory.Harvesting:\n                return 'Harvesting Buildings';\n            case BuildCategory.Habitation:\n                return 'Habitation & Life Support';\n            case BuildCategory.Power:\n                return 'Power Generation';\n            default:\n                return 'Buildings';\n        }\n    }\n    setPlacingMode(placing) {\n        this.placingMode = placing;\n    }\n    isPlacingMode() {\n        return this.placingMode;\n    }\n    hideQuickButtons() {\n        this.showQuickButtons = false;\n    }\n    drawResearchTree(overlayX, overlayY, overlayWidth, overlayHeight) {\n        // Title\n        this.ctx.fillStyle = '#9933ff';\n        this.ctx.font = '24px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'top';\n        this.ctx.fillText('Research & Development', overlayX + overlayWidth / 2, overlayY + 20);\n        // Current science display\n        const science = Math.floor(this.colony.resources.get(_colony__WEBPACK_IMPORTED_MODULE_0__.ResourceType.Science) || 0);\n        this.ctx.fillStyle = '#66ccff';\n        this.ctx.font = '16px Arial';\n        this.ctx.fillText(`Available Science: ${science}`, overlayX + overlayWidth / 2, overlayY + 50);\n        // Research tree grid\n        const startY = overlayY + 90;\n        const techWidth = 120;\n        const techHeight = 60;\n        const techSpacing = 140;\n        const tierSpacing = 80;\n        // Group techs by tier\n        const techsByTier = {};\n        Object.entries(_colony__WEBPACK_IMPORTED_MODULE_0__.TECHS).forEach(([id, spec]) => {\n            if (!techsByTier[spec.tier]) {\n                techsByTier[spec.tier] = [];\n            }\n            techsByTier[spec.tier].push(id);\n        });\n        // Draw tier by tier\n        let currentY = startY;\n        for (let tier = 1; tier <= 5; tier++) {\n            if (!techsByTier[tier])\n                continue;\n            // Tier label\n            this.ctx.fillStyle = '#00ff00';\n            this.ctx.font = '14px Arial';\n            this.ctx.textAlign = 'left';\n            this.ctx.fillText(`Tier ${tier}`, overlayX + 20, currentY + 15);\n            const techs = techsByTier[tier];\n            const rowStartX = overlayX + 80;\n            techs.forEach((techId, index) => {\n                const spec = _colony__WEBPACK_IMPORTED_MODULE_0__.TECHS[techId];\n                const techX = rowStartX + (index % 4) * techSpacing;\n                const techY = currentY + Math.floor(index / 4) * (techHeight + 10);\n                // Skip if would go outside overlay\n                if (techY + techHeight > overlayY + overlayHeight - 20)\n                    return;\n                const isResearched = this.colony.isResearched(techId);\n                const canResearch = this.colony.canResearchTech(techId);\n                const hasPrereqs = !spec.prerequisites || spec.prerequisites.every(p => this.colony.isResearched(p));\n                // Tech button\n                const btn = {\n                    rect: { x: techX, y: techY, width: techWidth, height: techHeight },\n                    text: techId,\n                    onClick: () => {\n                        if (canResearch) {\n                            this.colony.unlockTech(techId);\n                        }\n                    },\n                    enabled: canResearch\n                };\n                this.buttons.push(btn);\n                // Color based on status\n                let bgColor = '#333333';\n                let borderColor = '#666666';\n                let textColor = '#888888';\n                if (isResearched) {\n                    bgColor = '#003300';\n                    borderColor = '#00ff00';\n                    textColor = '#00ff00';\n                }\n                else if (canResearch) {\n                    bgColor = '#330033';\n                    borderColor = '#9933ff';\n                    textColor = '#9933ff';\n                }\n                else if (hasPrereqs) {\n                    bgColor = '#331100';\n                    borderColor = '#ff6600';\n                    textColor = '#ff6600';\n                }\n                // Draw tech box\n                this.ctx.fillStyle = bgColor;\n                this.ctx.fillRect(techX, techY, techWidth, techHeight);\n                this.ctx.strokeStyle = borderColor;\n                this.ctx.strokeRect(techX, techY, techWidth, techHeight);\n                // Tech name and cost\n                this.ctx.fillStyle = textColor;\n                this.ctx.font = '10px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'top';\n                // Wrap text if too long\n                const words = techId.split(' ');\n                let line = '';\n                let y = techY + 5;\n                words.forEach(word => {\n                    if (line.length + word.length > 15) {\n                        this.ctx.fillText(line, techX + techWidth / 2, y);\n                        line = word + ' ';\n                        y += 12;\n                    }\n                    else {\n                        line += word + ' ';\n                    }\n                });\n                if (line.trim()) {\n                    this.ctx.fillText(line.trim(), techX + techWidth / 2, y);\n                }\n                // Cost\n                this.ctx.font = '9px Arial';\n                this.ctx.fillStyle = '#66ccff';\n                this.ctx.fillText(`${spec.cost} Science`, techX + techWidth / 2, techY + techHeight - 15);\n                // Prerequisites indicator\n                if (spec.prerequisites && !isResearched) {\n                    const missingPrereqs = spec.prerequisites.filter(p => !this.colony.isResearched(p));\n                    if (missingPrereqs.length > 0) {\n                        this.ctx.fillStyle = '#ff4444';\n                        this.ctx.font = '8px Arial';\n                        this.ctx.fillText(`Needs: ${missingPrereqs.length} prereq`, techX + techWidth / 2, techY + techHeight - 5);\n                    }\n                }\n            });\n            currentY += Math.ceil(techs.length / 4) * (techHeight + 10) + tierSpacing;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ksp-game/./src/ui.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;